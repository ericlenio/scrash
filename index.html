<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passwords</title>
    
    <script src="https://cdn.jsdelivr.net/npm/openpgp@6.3.0/dist/openpgp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 40px auto; padding: 20px; line-height: 1.6; color: #333; }
        h1 { border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .step { background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        
        input[type="text"], input[type="password"] { width: 100%; padding: 8px; margin-bottom: 10px; box-sizing: border-box; }
        
        button { background: #2ea44f; color: white; border: none; padding: 12px 24px; border-radius: 6px; font-size: 16px; cursor: pointer; width: 100%; margin-bottom: 10px; }
        button:hover { background: #2c974b; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.secondary { background: #0366d6; }
        button.secondary:hover { background: #0255b3; }
        button.cancel { background: #d73a49; }
        button.cancel:hover { background: #b92b3a; }

        #output { background: #222; color: #0f0; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; display: none; margin-top: 20px; }
        .error { color: #d73a49; background: #ffdce0; padding: 10px; border-radius: 5px; display: none; margin-top: 10px; }
        
        .status-tag { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 10px; }
        .status-ok { background: #dafbe1; color: #1a7f37; }
        .status-fail { background: #ffdce0; color: #d73a49; }
        .status-loading { background: #dbedff; color: #0366d6; }

        #cameraContainer { display: none; margin-top: 15px; position: relative; background: #000; border-radius: 8px; overflow: hidden; }
        #cameraVideo { width: 100%; display: block; }
        #cameraOverlay { position: absolute; bottom: 10px; left: 0; right: 0; text-align: center; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8); pointer-events: none; }

        /* NEW: Table Styling */
        table.decrypted-table {
            width: 100%;
            border-collapse: collapse;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; /* Fixed Font */
            color: #e6edf3;
            font-size: 0.9em;
        }
        table.decrypted-table td {
            border: 1px solid #444;
            padding: 8px 12px;
            vertical-align: top;
        }
        /* Style for Section Headers */
        table.decrypted-table tr.section-header td {
            background-color: #444;
            color: #fff;
            font-weight: bold;
            text-align: left;
            border-top: 2px solid #666;
            padding-top: 15px;
        }
    </style>
</head>
<body>

    <h1>Passwords</h1>
    
    <p>Loading file: <code>./profile/el13/passwords.gpg</code> <span id="fileStatus"></span></p>

    <div class="step">
        <label>1. Upload Key</label>
        
        <button class="secondary" id="scanBtn" onclick="startCameraScan()">Scan QR with Camera</button>
        
        <div id="cameraContainer">
            <video id="cameraVideo" playsinline></video>
            <div id="cameraOverlay">Point camera at QR Code...</div>
            <button class="cancel" onclick="stopCameraScan()" style="position: absolute; top: 10px; right: 10px; width: auto; padding: 5px 10px; font-size: 0.8em;">Stop</button>
        </div>

        <div id="qrStatus" style="font-size: 1em; color: #666;"></div>
    </div>

    <div class="step">
        <label>2. Enter Key Passphrase</label>
        
        <form onsubmit="event.preventDefault(); decryptProcess();">
            <input type="password" id="passphrase" placeholder="Passphrase..." autocomplete="current-password">
            <button type="submit" id="decryptBtn" disabled>Decrypt File</button>
        </form>

        <div id="errorMsg" class="error"></div>
    </div>

    <div id="output"></div>

    <script>
        let privateKeyObj = null;
        let encryptedFileContent = null;
        const TARGET_FILE = './profile/el13/passwords.gpg';
        
        let videoStream = null;
        let isScanning = false;

        window.onload = async function() {
            updateFileStatus('loading', 'Fetching file...');
            try {
                const response = await fetch(TARGET_FILE);
                if (!response.ok) throw new Error(`HTTP ${response.status} Not Found`);
                encryptedFileContent = await response.text();
                updateFileStatus('ok', `Ready (Armored Text, ${encryptedFileContent.length} characters)`);
                checkReadyState();
            } catch (e) {
                updateFileStatus('fail', `Failed to load: ${e.message}`);
                console.error(e);
            }
        };

        function updateFileStatus(type, msg) {
            const el = document.getElementById('fileStatus');
            el.className = `status-tag status-${type}`;
            el.innerText = msg;
        }

        async function startCameraScan() {
            const video = document.getElementById('cameraVideo');
            const container = document.getElementById('cameraContainer');
            const btn = document.getElementById('scanBtn');

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("Camera API not supported in this browser (Note: requires HTTPS or localhost)");
                return;
            }

            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                video.srcObject = videoStream;
                video.setAttribute("playsinline", true);
                video.play();
                
                container.style.display = "block";
                btn.style.display = "none";
                isScanning = true;
                
                requestAnimationFrame(tick);
                updateQrStatus('loading', 'Searching for QR code...');
            } catch (err) {
                console.error(err);
                alert("Could not access camera: " + err.message);
            }
        }

        function stopCameraScan() {
            const video = document.getElementById('cameraVideo');
            const container = document.getElementById('cameraContainer');
            const btn = document.getElementById('scanBtn');

            isScanning = false;
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            container.style.display = "none";
            btn.style.display = "inline-block";
        }

        function tick() {
            if (!isScanning) return;
            const video = document.getElementById('cameraVideo');
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement("canvas");
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });

                if (code) {
                    stopCameraScan();
                    loadKeyBinary(new Uint8Array(code.binaryData));
                }
            }
            requestAnimationFrame(tick);
        }

        // REMOVED: File Input Event Listener (Code block removed as requested)

        function updateQrStatus(type, msg) {
            document.getElementById('qrStatus').innerHTML = `<span class='status-tag status-${type}'>${msg}</span>`;
        }

        async function loadKeyBinary(binaryKeyData) {
            try {
                privateKeyObj = await openpgp.readKey({ binaryKey: binaryKeyData });
                document.getElementById('qrStatus').innerHTML = `<span class='status-tag status-ok'>Key was successfully loaded: ${privateKeyObj.getKeyID().toHex()}</span>`;
                document.getElementById('errorMsg').style.display = 'none';
                checkReadyState();
            } catch (err) {
                showError("Failed to parse key: " + err.message);
            }
        }

        function checkReadyState() {
            if (privateKeyObj && encryptedFileContent) {
                document.getElementById('decryptBtn').disabled = false;
                document.getElementById('decryptBtn').innerText = "Decrypt File";
            }
        }

        async function decryptProcess() {
            const pass = document.getElementById('passphrase').value;
            const outputDiv = document.getElementById('output');
            
            outputDiv.style.display = 'none';
            document.getElementById('errorMsg').style.display = 'none';

            if (!pass) { showError("Enter passphrase."); return; }

            try {
                const decryptedKey = await openpgp.decryptKey({
                    privateKey: privateKeyObj,
                    passphrase: pass
                });

                const message = await openpgp.readMessage({ armoredMessage: encryptedFileContent });
                const { data: decrypted } = await openpgp.decrypt({
                    message: message,
                    decryptionKeys: decryptedKey
                });

                // --- Format as Table ---
                const lines = decrypted.split('\n');
                let tableHtml = '<table class="decrypted-table">';
                let headerBuffer = "";
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    // CHECK FOR SECTION HEADER (#)
                    if (line.startsWith('#')) {
                        // Strip leading '#' and whitespace
                        const cleanLine = line.replace(/^#+\s*/, '');
                        // Add to buffer (space separated if multiple lines)
                        headerBuffer += (headerBuffer ? " " : "") + cleanLine;
                    } 
                    else {
                        // If we have a buffered header, output it now
                        if (headerBuffer) {
                            tableHtml += `
                                <tr class="section-header">
                                    <td colspan="100%">${headerBuffer}</td>
                                </tr>`;
                            headerBuffer = ""; // Reset
                        }

                        // Normal Data Row
                        const parts = line.split(':');
                        tableHtml += '<tr>';
                        
                        parts.forEach((part, index) => {
                            let text = part.trim();
                            // Truncate 2nd column and beyond (index > 0) to 20 chars
                            if (index > 0 && text.length > 20) {
                                text = text.substring(0, 20) + "...";
                            }
                            tableHtml += `<td>${text}</td>`;
                        });
                        
                        tableHtml += '</tr>';
                    }
                }

                // Flush remaining header if file ends with one
                if (headerBuffer) {
                    tableHtml += `<tr class="section-header"><td colspan="100%">${headerBuffer}</td></tr>`;
                }

                tableHtml += '</table>';

                outputDiv.style.display = 'block';
                outputDiv.innerHTML = tableHtml;

            } catch (err) {
                showError(err.message);
            }
        }

        function showError(msg) {
            const el = document.getElementById('errorMsg');
            el.innerText = msg;
            el.style.display = 'block';
        }
    </script>
</body>
</html>
