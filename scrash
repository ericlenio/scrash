#! /usr/bin/env bash

shell_init_args=()
mode=client_server

usage() {
  echo "Usage: $0 [-h][-p port][-P profile][-t][-g test_groups]
options:
-h           this help
-p port      port number of the Server.js process, default is $SCR_PORT
-s           client/server mode: start a server process inside a new gnu screen session
-P profile   select a custom scrash profile, defaults to \$USER

developer options:
-t           test mode (runs all the test cases)
-g           in test mode, specifies a particular test group to be run
"
}

init() {
  eval $(node -r fs -r path -e 'const h=path.join(fs.realpathSync(process.argv[1]),".."); const p=require(path.join(h,"package.json")); console.log(`export SCR_HOME="${h}" SCR_VERSION=${p.version}`);' -- $0)
  export SCR_PORT=4553
  export SCR_PROFILE=$USER
  export SCR_SSH_USER=$USER
  # force lowercase hostname for SCR_SSH_HOST because ssh-keyscan forces
  # lowercase hostnames in it's output
  export SCR_SSH_HOST=$(hostname|tr "[:upper:]" "[:lower:]")
  if [ "$SSH_AUTH_SOCK" ]; then
    export SCR_SSH_AUTH_SOCK=$SSH_AUTH_SOCK
  fi
  unset SSH_AUTH_SOCK
  export SCR_ENV=${SCR_ENV:=dev}
  while builtin getopts "hp:P:tg:" opt; do
    case $opt in
      (h)
        usage
        exit
        ;;
      (p)
        SCR_PORT=$OPTARG
        ;;
      (P)
        SCR_PROFILE=$OPTARG
        ;;
      (t)
        mode=test
        SCR_ENV=test
        #SCR_PORT=$((50000+$RANDOM % 10000))
        SCR_PORT=55554
        ;;
      (g)
        test_groups="$OPTARG"
        ;;
    esac
  done
  export SCR_PASSWORD_FILE="$SCR_HOME/profile/$SCR_PROFILE/passwords.gpg"
  export SCR_PORT_0=$SCR_PORT
  BASH_FUNCTIONS="$SCR_HOME"/src/bash/bash-functions
  BASH_FUNCTIONS_TEST="$SCR_HOME"/src/bash/bash-functions-test
  PROFILE_BASH_FUNCTIONS="$SCR_HOME"/profile/$SCR_PROFILE/bash-functions
  PROFILE_BASH_FUNCTIONS_LOCALHOST="$SCR_HOME"/profile/$SCR_PROFILE/bash-functions-localhost
}

get_function_names() {
  local file="$1"
  env -i bash --norc --noprofile -c "source \"$file\"; compgen -A function"
}

build_func() {
  local funcname=$1 file="${2:-/dev/stdin}"
  printf -- "%s() { echo '%s' | openssl enc -d -a -A | gzip -dc; }" $funcname $(gzip -9c <"$file" | openssl enc -a -A)
}

load_bash_functions() {
  # funclist: maintain a list of all loaded bash functions used by scrash
  local funclist=()
  local bash_files=("$BASH_FUNCTIONS" "$PROFILE_BASH_FUNCTIONS" "$PROFILE_BASH_FUNCTIONS_LOCALHOST") host_specific_rcfile tmpfile=$(mktemp)
  if [ $SCR_ENV = test ]; then
    bash_files+=($BASH_FUNCTIONS_TEST)
  fi
  for f in "${bash_files[@]}"; do
    [ ! -f "$f" ] && continue
    source "$f"
    funclist+=($(get_function_names "$f"))
  done
  export SCR_LOCALHOST_FUNCS=$([ -f "$PROFILE_BASH_FUNCTIONS_LOCALHOST" ] && get_function_names "$PROFILE_BASH_FUNCTIONS_LOCALHOST")
  for rcfile in "$SCR_HOME"/profile/$SCR_PROFILE/{screenrc,bashrc,vimrc}; do
    host_specific_rcfile="$rcfile-$(hostname)"
    rcfile_base=$(basename "$rcfile")
    funcname="-$rcfile_base"
    if [ -f "$rcfile" ]; then
      cp "$rcfile" $tmpfile
    fi
    if [ -f "$host_specific_rcfile" ]; then
      cat "$host_specific_rcfile" >> $tmpfile
    fi
    if [ -s $tmpfile ]; then
      funcdef=$(build_func $funcname $tmpfile)
    else
      printf -v funcdef -- "%s() { :; }" $funcname
    fi
    eval -- "$funcdef"
    funclist+=($funcname)
    #if [ $rcfile_base = bashrc ]; then
      #source "$rcfile"
    #fi
  done
  rm $tmpfile
  for vim_plugin in $(find "$SCR_HOME"/src/vim -name '*.vim'); do
    plugin=$(basename "$vim_plugin" .vim)
    plugin_func="-vim-plugin-$plugin"
    funcdef=$(grep -v -e '^ *"' "$vim_plugin" | build_func $plugin_func)
    eval -- "$funcdef"
    funclist+=($plugin_func)
  done
  -shell-init -C
  printf -v funcdef -- "scr_function_list() { for f in ${funclist[*]}; do printf '%%s ' \$f; done; }"
  eval -- "$funcdef"
  export -f scr_function_list
}

scr_function_list_dump() {
  local f
  for f in $(scr_function_list); do
    printf '%s:%s\n' $f $(declare -f -- $f | openssl enc -a -A)
  done
}

export -f scr_function_list_dump

scr_server() {
  scr_function_list_dump | npm start --prefix="$SCR_HOME" -- -p $SCR_PORT
  echo "$FUNCNAME: server has stopped, \"$FUNCNAME\" to restart it" >&2
  exec bash
}

export -f scr_server

main() {
  case $mode in
    (client_server)
      load_bash_functions
      shell_init_args+=(-s $(-ssh-serialize-cmd screen bash -c scr_server))
      ;;
    (test)
      load_bash_functions
      cd $SCR_HOME
      cmd=(exec ./tests/test)
      if [ "$test_groups" ]; then
        cmd+=(-g "$test_groups")
      fi
      "${cmd[@]}"
      ;;
    (*)
      # client mode, not really used a lot
      shell_init_args+=(-s 1)
      url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
      eval -- "$(curl -S -f -s --compressed $url)"
      ;;
  esac
  -shell-init "${shell_init_args[@]}"
}

init "$@"
main
