# vim:filetype=bash

-prompt-command() {
  if [[ $BASHOPTS =~ expand_aliases ]]; then
    # disable aliases
    shopt -u expand_aliases
    unalias -a
  fi
  PS1=$SCR_PS1
  if [ "$STY" -a ${#SUDO_USER} -eq 0 -a ! -f "$EDITOR" ]; then
    if [ $(($(date +%s)-$SCR_SCREEN_START)) -gt 3600 ]; then
      # for a long running gnu screen session, make sure $EDITOR exists; it
      # will get wiped from /tmp from time to time
      echo "missing $EDITOR, creating it now"
      v --version >/dev/null
    fi
  fi
}

v() {
  vim "$@"
}

l() {
  ls -laF "$@"
}

c() {
  -set-clipboard "$@"
}

#
# personal grep tool when working with source code in some dev project: assumed
# you are cd'd into the main project dir and wanting to recursively grep for
# something
#
-grep() (
  local opts=":a" opt OPTIND all_files=0 skip_paths files
  skip_paths=(
    '**/.git/*'
    '**/.svn*'
    '*.class'
    '*.jar'
    '*.swp'
    '*.png'
    '*.jpg'
    '*.pdf'
    '*.img'
    '*.iso'
  )
  while builtin getopts $opts opt; do
    case $opt in
      (a) all_files=1
        shift
        ;;
    esac
  done
  if [ $all_files = 0 ]; then
    skip_paths+=(
      '**/dist/*'
      '**/build/*'
      '**/node_modules/*'
    )
  fi
  set -o noglob
  find . -type f $(
    for path in "${skip_paths[@]}"; do
      printf "! -path %s " "${path// /\ }"
    done
  ) -print0 | xargs -0 egrep -H "$@"
)

-pwgen() {
  local length=${1:-32}
  # skip colons, I use them in passwords.gpg as a delimeter
  pwgen -cnyr : $length 1
}

-openssl_s_client_show_certs() (
  local arg1 usage show_cert_details host port hostport cert_line=0 n=1 opts="dhv" opt verbose=0 debug=0 certs OPTARG OPTIND
  usage() {
    {
      echo "usage: ${FUNCNAME[1]} [-h][-d][-v] {hostname:port|/path/to/pem/certs}"
      echo "or, pipe PEM certs to $FUNCNAME"
      echo "use -v to display the certs"
      echo "use -d to turn on debug mode to show s_client details"
    } >/dev/tty
  }
  show_cert_details() {
    local cert="$1"
    echo "################ CERT #$n"
    while read line; do
      printf "# %s\n" "$line"
    done < <(echo "$cert" | openssl x509 -noout -subject -issuer -startdate -enddate)
    if [ $verbose = 1 ]; then
      echo -n "$cert"
    fi
  }
  while builtin getopts $opts opt; do
    case $opt in
      (h) usage
        return
        ;;
      (d) debug=1
        ;;
      (v) verbose=1
        ;;
    esac
  done
  shift $(($OPTIND-1))
  if [ -t 0 ]; then
    arg1="$1"
    if [ -z "$arg1"  ]; then
      usage
      return 1
    fi
    if [ -f "$arg1" ]; then
      exec 0<"$arg1"
    else
      hostport="$arg1"
      if ! [[ "$hostport" =~ ^([-\.[:alnum:]]+):([0-9]+)$ ]]; then
        usage
        return 1
      fi
      host=${BASH_REMATCH[1]}
      port=${BASH_REMATCH[2]}
      openssl_cmd=(openssl s_client -showcerts -servername $host -connect $host:$port)
      if [ $debug = 0 ]; then
        openssl_cmd+=('2>/dev/null')
      else
        openssl_cmd+=(-debug)
        echo "${openssl_cmd[@]}"
      fi
      eval "exec 0< <(${openssl_cmd[@]} </dev/null || true)"
    fi
  fi
  while read line; do
    if [ $debug = 1 ]; then
      echo "$line"
    fi
    if [[ "$line" =~ ^-----BEGIN\ CERTIFICATE----- ]]; then
      cert_line=1
      cert=""
    fi
    if [ $cert_line = 1 ]; then
      cert+="$line"$'\n'
    fi
    if [[ "$line" =~ ^-----END\ CERTIFICATE----- ]]; then
      cert_line=0
      show_cert_details "$cert"
      let n++
      certs+="$cert"
    fi
  done
)

-fixdate() {
  ntpdate -u pool.ntp.org
}

-tlog() {
  env time "$@" 2>&1 | tee "$1".log
}

-openbsd-pkg-search() {
  local search_term="$1"
  if [ -z "$search_term" ]; then
    printf "%s: no search term given\n" $FUNCNAME
    return 1
  fi
  echo "SELECT fullpkgname,comment FROM ports WHERE lower(comment) LIKE '%${search_term}%' OR lower(fullpkgname) LIKE '%${search_term}%' ORDER BY fullpkgname" | \
  sqlite3 /usr/local/share/sqlports
}

# 
# this function to help me swap out my old ssh key with a new one
-ssh-swap-key() (
  local ssh_auth=$HOME/.ssh/authorized_keys tmp key_type key_options key_data key_comment old_key_data \
    ssh_auth_keys_pattern ssh_auth_line new_key_type new_key_data new_key_comment found=0 \
    ubuntu_12_key_types="ecdsa-sha2-nistp256 ecdsa-sha2-nistp384 ecdsa-sha2-nistp521 ssh-dss ssh-rsa" key_types

    key_types=($(env ssh -Q key 2>/dev/null || echo "$ubuntu_12_key_types"))
    local IFS='|'
    ssh_auth_keys_pattern=(
      # see man sshd, "AUTHORIZED_KEYS FILE FORMAT"
      #
      # first come options, which are optional
      '^([^[:blank:]].+ )?'
      # then key type (ssh-rsa, ssh-ed25119, etc.)
      "(${key_types[*]})"
      # space
      '\ '
      # the actual key
      '([^[:blank:]]+)'
      # space
      '\ '
      # comment
      '(.+)$'
    )
  unset IFS
  set -e
  -match-auth-keys-line() {
    local ssh_auth_line="$1" patt IFS=''
    read patt <<<"${ssh_auth_keys_pattern[*]}"
    unset IFS
    [[ "$ssh_auth_line" =~ $patt ]] || return $?
    key_options="${BASH_REMATCH[1]}"
    key_type="${BASH_REMATCH[2]}"
    key_data="${BASH_REMATCH[3]}"
    key_comment="${BASH_REMATCH[4]}"
  }
  if ! -match-auth-keys-line "$SCR_SSH_OLD_KEY"; then
    echo "$FUNCNAME: could not parse SCR_SSH_OLD_KEY" >&2
    return 1
  fi
  old_key_data="$key_data"
  if ! -match-auth-keys-line "$SCR_SSH_CURRENT_KEY"; then
    echo "$FUNCNAME: could not parse SCR_SSH_CURRENT_KEY" >&2
    env ssh -Q key 2>/dev/null || echo "(probably due to very old ssh: $(env ssh -V 2>&1))" >&2
    return 1
  fi
  new_key_type="$key_type"
  new_key_data="$key_data"
  new_key_comment="$key_comment"
  for ssh_auth in "$ssh_auth" "${ssh_auth}2"; do
    if [ -f "$ssh_auth" ]; then
      echo "$FUNCNAME: checking $ssh_auth for updated ssh key" >/dev/tty
      if fgrep -q "$new_key_data" "$ssh_auth"; then
        echo "$FUNCNAME: new key found in $ssh_auth" >/dev/tty
        continue
      fi
      if fgrep -q "$old_key_data" "$ssh_auth"; then
        tmp=$(mktemp)
        while true; do
          read ssh_auth_line || break
          if -match-auth-keys-line "$ssh_auth_line"; then
            if [ "$key_data" = "$old_key_data" ]; then
              found=1
              printf "%s%s %s %s\n" "$key_options" $new_key_type "$new_key_data" "$new_key_comment"
            else
              echo "$ssh_auth_line"
            fi
          else
            echo "$ssh_auth_line"
          fi
        done <"$ssh_auth" >>$tmp
        if [ $found = 1 ]; then
          diff "$ssh_auth" $tmp || true
          read -p "Found the old ssh key, ok to update to the new key as shown above (default=n)? "
          if [ "${REPLY:0:1}" = y ]; then
            cp $tmp "$ssh_auth"
          fi
        fi
        rm $tmp
      fi
    fi
  done
)
