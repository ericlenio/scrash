# vim:filetype=bash
#
# functions here will only load for the system on which scrash is running

# -pw retrieves a password based on the given key, which can be supplied as arg
# 1 or passed in stdin
#
# limitation: password cannot contain a colon because that is assumed to be the
# delimiter here
-pw-localhost() {
  local opt OPTIND search_key pw_line pw n index=-1 split_char=':' b64=0 pw_file="$SCR_PASSWORD_FILE" found=0 mode=query git_dir
  while builtin getopts "cdhbi:p:eIA:" opt; do
    case $opt in
      (h)
        echo "usage: $FUNCNAME [-cdhbeI][-i index][-p password_file] search_key"
        echo "-h: this help"
        echo "-b: base64 encode the result"
        echo "-c: commit changes"
        echo "-d: show diff on uncommitted changes"
        echo "-e: edit the password file"
        echo "-i: for each matched line, return this index value of the line when it is split by \"$split_char\""
        echo "-I: check for existence of password file, and initialize it if necessary"
        echo "-p: specify an alternate password file, default=$pw_file"
        return
        ;;
      (A)
        local args arg
        -deserialize-args $OPTARG
        $FUNCNAME "${args[@]}"
        return $?
        ;;
      (b)
        b64=1
        ;;
      (i)
        # for each line found, within that line what part of the line do we want?
        # default is the last index
        index=$OPTARG
        ;;
      (I)
        mode=init
        ;;
      (p)
        pw_file="$OPTARG"
        ;;
      (e)
        mode=edit
        ;;
      (d)
        mode=diff
        ;;
      (c)
        mode=commit
        # break and let remaining flags pass to "git commit"
        break
        ;;
    esac
  done
  shift $(($OPTIND-1))
  git_dir=$(dirname "$pw_file")
  case $mode in
    (init)
      if [ $SCR_SSH_LEVEL -gt 0 ]; then
        echo "cannot do this at SCR_SSH_LEVEL=$SCR_SSH_LEVEL" >&2
        return 1
      fi
      if [ ! -f "$pw_file" ]; then
        # create a blank password file
        local tmpfile=$(mktemp)
        printf "#\n# enter secrets here in this format:\n# <login url or description>:<username>:<password>\n#\n" > $tmpfile
        gpg -ea -r $SCR_PASSWORD_KEY_ID -o $pw_file $tmpfile
        rm $tmpfile
        read -p "just created $pw_file, you should add it to git now"
      fi
      ;;
    (edit)
      if [ $SCR_SSH_LEVEL -gt 0 ]; then
        echo "cannot do this at SCR_SSH_LEVEL=$SCR_SSH_LEVEL" >&2
        return 1
      fi
      vim "$pw_file"
      ;;
    (query)
      search_key="$1"
      if [ -z "$search_key" ]; then
        return 1
      fi
      shift
      if [ $SCR_SSH_LEVEL = 0 ]; then
        if [ ! -r "$pw_file" ]; then
          echo "$FUNCNAME: could not read password file: $pw_file" >&2
          return 1
        fi
        while read -r pw_line; do
          found=1
          IFS="$split_char" builtin read -r -a pw_line <<<"$pw_line"
          if [ "$index" ]; then
            let n=$index || true
          else
            let n=${#pw_line[*]}-1
          fi
          pw="${pw_line[$n]}"
          if [ $b64 = 0 ]; then
            echo "$pw"
          else
            printf "%s\n" $(printf %s "$pw" | openssl enc -a -A)
          fi
        done < <(gpg -qd "$pw_file" | grep "$search_key")
        if [ $found = 0 ]; then
          return 1
        fi
      elif -ws -o /scr-get-password --data-urlencode "searchKey=$search_key" --data-urlencode "b64=$b64"  --data-urlencode "index=$index" --data-urlencode "pwFile=$pw_file" "$@"; then
        :
      else
        echo "$FUNCNAME: problem with OTP" >&2
        return 1
      fi
      ;;
    (diff)
      (
        cd "$git_dir"
        if ! git diff --quiet $(basename "$pw_file"); then
          diff <(git diff $(basename "$pw_file") | patch -R -p 0 -o - $(basename "$pw_file") | gpg -qd) <(gpg -qd "$pw_file")
        fi
      )
      ;;
    (commit)
      (
        cd "$git_dir"
        if ! git diff --quiet $(basename "$pw_file"); then
          git commit $(basename "$pw_file") "$@"
        fi
      )
      ;;
  esac
}
