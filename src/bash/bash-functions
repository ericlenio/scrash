# vim:filetype=bash

-log() {
  if [ $# = 0 ]; then
    if [ "$SCR_DEBUG" = 1 ]; then
      export SCR_DEBUG=0
    else
      export SCR_DEBUG=1
    fi
    echo "logging is now $([ $SCR_DEBUG = 0 ] && echo OFF || echo ON)" >&2
    return
  fi
  if [ "$SCR_DEBUG" = 1 ]; then
    echo "$*" >&2
  fi
}

-add-path() {
  while [ $# -gt 0 ]; do
    [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]] && PATH="$1:$PATH" && export PATH
    shift
  done
}

-tty-echo() {
  local tty=/dev/tty
  #if [ "$SSH_CLIENT" ]; then
    #tty=$SSH_TTY
  #fi
  if [ -e "$tty" ]; then
    echo "$@" >$tty
  fi
}

-vars() {
  set | egrep '^(EDITOR|SCR|STY|VIM|SSH|GIT_SSH)' | sort
}

-clear-cache() {
  if [ "$SUDO_USER" ]; then
    -tty-echo "$FUNCNAME: skip because we detected sudo is in effect" >&2
    return
  fi
  if [[ "$SCR_TMPDIR" =~ ^/tmp/ ]]; then
    rm -rf "$SCR_TMPDIR"/*
    -tty-echo "cleaned out $SCR_TMPDIR"
  fi
}

-random-string() {
  local length=${1:-16} r="" c
  while [ ${#r} -lt $length ]; do
    read -n 1 c
    r+=$c
  done < <(LC_ALL=C tr -dc A-Za-z0-9 </dev/urandom || true)
  echo $r
}

-pick-sty() {
  local stys pick_sty pick_sty_line session_id curr_sty=${STY:-no_such_sty_exists}
  # make a pick list of available session ids
  stys=$(
    while read l; do
      if [[ "$l" =~ ^[[:blank:]]*([0-9]+\.[^[:blank:]]+)[[:blank:]]+([[:print:]]+) ]]; then
        pick_sty=${BASH_REMATCH[1]}
        pick_sty_status=${BASH_REMATCH[2]}
        echo "$pick_sty $pick_sty_status"
      fi
    done < <(env screen -ls | grep -v $curr_sty)
  )
  if [ -z "$stys" ]; then
    echo "No screen sessions detected." >/dev/tty
    return 0
  fi
  if ! pick_sty_line=$(-pick-something "Resume which session?" "$stys"); then
    return 1
  fi
  if [[ $pick_sty_line =~ ^([0-9]+\.([-[:alnum:]]+)) ]]; then
    pick_sty=${BASH_REMATCH[1]}
    session_id=${BASH_REMATCH[2]}
    echo $session_id
  else
    echo "$FUNCNAME: no match for pick_sty_line: $pick_sty_line" >&2
    return 1
  fi
}

#
# call within gnu screen to update important environment variables; in
# particular, this must be called prior to any call to -ws or -ssh
-screen-env() {
  local opts="uS:p" opt OPTIND update=0 v SCR_UPDATEABLE="SCR_PORT SSH_AUTH_SOCK" file_prefix=scr-sty-env- echo_port=0
  # keep STY local so we don't pollute parent shell when reconnecting to a gnu
  # screen session
  local STY=$STY
  while builtin getopts $opts opt; do
    case $opt in
      (u) update=1
        ;;
      (S) STY=$OPTARG
        ;;
      (p) echo_port=1
        ;;
    esac
  done
  if [ -z "$STY" ]; then
    echo "$FUNCNAME: no value for STY" >&2
    return 1
  fi
  local session_id=${STY##*.}
  local SCR_STY_ENV=$SCR_TMPDIR/$file_prefix$session_id
  if [ -z "$SUDO_USER" ]; then
    local old_env old_env_id
    for old_env in $SCR_TMPDIR/$file_prefix*; do
      if [[ $old_env =~ $file_prefix([:alnum:].*) ]]; then
        old_env_id=${BASH_REMATCH[1]}
        if ! screen -ls | grep -q $old_env_id; then
          rm -f $old_env
          echo "removed old fifo: $old_env" >&2
        fi
      fi
    done
  fi
  if [ $update = 1 ]; then
    # update critical environment variables
    if {
      for v in $SCR_UPDATEABLE; do
        if [ "${!v}" ]; then
          printf "%s='%s'\n" $v ${!v}
        fi
      done
    } > $SCR_STY_ENV; then
      printf "%s: successful update on %s:\n%s\n" $FUNCNAME $session_id "$(<$SCR_STY_ENV)" >&2
      return
    else
      echo "$FUNCNAME: failed to write to $SCR_STY_ENV" >&2
      return 1
    fi
  fi
  if [ ! -e $SCR_STY_ENV ]; then
    touch $SCR_STY_ENV
  fi
  if ! source $SCR_STY_ENV; then
    echo "$FUNCNAME: failed to load data from $SCR_STY_ENV" >&2
    return 1
  fi
  if [ $echo_port = 1 ]; then
    echo $SCR_PORT
  fi
}

# wrapper around gnu screen
screen() {
  local i i2 next_arg rcfile session_id_prefix="scr" session_id opt cmd=() screen_cmd=() esc=^Aa update=0 command=0 skip=0
  for ((i=1;i<=$#;i++)); do
    i2=$((i+1))
    next_arg="${!i2}"
    opt="${!i}"
    skip=0
    case $opt in
      (--generate-session-id)
        printf "%s-%s" $session_id_prefix $(-random-string 4)
        return
        ;;
      (-ls|-list|-wipe|-Q|-D|-R)
        env screen "$@"
        return $?
        ;;
      (-X)
        if [ $update = 1 ]; then
          if ! -screen-env -S $session_id -u; then
            return $?
          fi
        fi
        env screen "$@"
        return $?
        ;;
      (-r)
        if [[ "$next_arg" =~ ^[[:alnum:]] ]]; then
          session_id=$next_arg
        else
          if ! session_id=$(-pick-sty); then
            return 1
          fi
        fi
        if [[ $session_id =~ ^$session_id_prefix ]]; then
          if ! -screen-env -S $session_id -u; then
            return $?
          fi
        fi
        set -- "${@:1:i-1}" -r $session_id "${@:i+1}"
        cmd+=("$@")
        env screen "${cmd[@]}"
        return $?
        ;;
      (-u)
        set -- "${@:1:i-1}" "${@:i+1}"
        let i-=1
        skip=1
        update=1
        ;;
      (-S)
        session_id=$next_arg
        cmd+=(-S $session_id)
        let i+=1
        continue
        ;;
      (-c)
        rcfile=$next_arg
        cmd+=(-c $rcfile)
        let i+=1
        continue
        ;;
      ([a-zA-Z]*)
        screen_cmd=("${@:$i:$#}")
        break
        ;;
    esac
    [ $skip = 0 ] && cmd+=("$opt")
  done
  if ! [ "$session_id" ]; then
    session_id=$($FUNCNAME --generate-session-id)
    cmd+=(-S $session_id)
  fi
  if [ -z "$rcfile" -a "$session_id" ]; then
    rcfile=$SCR_SCREENRC
    if [ ! -f $rcfile ]; then
      if ! -screenrc > $rcfile; then
        return $?
      fi
    fi
    cmd+=(-c $rcfile)
  fi
  if [ $SCR_SSH_LEVEL -gt 0 ]; then
    esc=^Ee
  fi
  [ $TERM = dumb ] && TERM=screen
  # strip off "screen." prefix from $TERM to avoid "$TERM too long" issue
  cmd+=(-T ${TERM#screen.} -ln -e$esc)
  export SCR_SCREEN_START=$(date +%s)
  env screen "${cmd[@]}" "${screen_cmd[@]}"
}

-ws() {
  [ "$STY" ] && -screen-env
  local base_url=http://127.0.0.1:$SCR_PORT endpoint url rc=0 opts="o" opt OPTIND otp='' need_otp=0
  while builtin getopts $opts opt; do
    case $opt in
      (o) need_otp=1
        ;;
    esac
  done
  shift $(($OPTIND-1))
  endpoint=$1
  shift
  if [ $need_otp = 1 ]; then
    -fetch-otps
    set -- -H "X-Scrash-Otp: $otp" "$@"
    -used-otp $otp
  fi
  printf -v url "%s%s" $base_url $endpoint
  set -- "$@" "$url"
  if NO_PROXY=127.0.0.1 curl --connect-timeout 5 -f -S -s "$@"; then
    :
  else
    rc=$?
    echo "$FUNCNAME: curl failed with arguments: $@" >&2
    echo "stack trace: ${FUNCNAME[*]}" >&2
  fi
  return $rc
}

-ws-about() {
  -ws /scr-about "$@"
}

-ws-hello-world() {
  -ws /scr-hello-world "$@"
}

-screen-shot() {
  local f t
  if [ -z "$STY" ]; then
    echo "$FUNCNAME: not running gnu screen" >&2
    return 1
  fi
  f=$(mktemp)
  t=$RANDOM
  if [ ! -e $EDITOR ]; then
    v --version >/dev/null
  fi
  env screen -X hardcopy $f
  env screen -t $t sh -c "$EDITOR -c \"set nonumber\" $f; rm $f"
  env screen -X select $t
}

vim() {
  if [ -z "$EDITOR" ]; then
    echo "$FUNCNAME: EDITOR is not set" >&2
    return 1
  fi
  local p d=$(dirname "$EDITOR")
  [ ! -d "$d" ] && mkdir -p "$d"
  if [ ! -e "$EDITOR" ]; then
    p='#!/usr/bin/env bash\n[ "$1" = "--version" ] && exec vim "$@"\n%s\n-shell-init\nexec vim "$@"\n'
    #local url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
    #eval "$(curl -S -f -s --compressed $url)"
    printf "$p" "$(-shell-init -D)" > "$EDITOR"
    chmod 755 "$EDITOR" || {
      echo "ERROR: could not chmod $EDITOR: $?" >&2
      return 1
    }
  fi
  p="$SCR_VIMRUNTIME/plugin/functions.vim"
  if [ ! -e "$p" ]; then
    if ! mkdir -p $(dirname "$p") || ! -vim-plugin-functions > "$p"; then
      return 1
    fi
  fi
  if [ ! -e "$SCR_VIMRC" ]; then
    -vimrc > "$SCR_VIMRC"
  fi
  "$EDITOR" "$@"
}

-shell-init() {
  local opts="CDvs:" opt OPTIND log_tty verbose=0 i fcns num_fcns test_mode=0 test_groups start clear_cache=0 declare_mode=0 show_test_groups version_file old_version
  while builtin getopts $opts opt; do
    case $opt in
      (v) verbose=1
        export SCR_DEBUG=1
        ;;
      (s)
        # pass start=1 to start an interactive shell, any other value is
        # assumed to be a base64 encoded command to be run (generated by
        # -ssh-serialize-cmd)
        start=$OPTARG
        ;;
      (D)
        # just declare all the functions
        declare_mode=1
        ;;
      (C)
        clear_cache=1
        ;;
    esac
  done
  if [ $declare_mode = 0 ]; then
    # SCR_ENV is like node's NODE_ENV, we can use it to create a separate name
    # space for run time files and such
    export SCR_ENV=${SCR_ENV:-dev}
    export SCR_TMPDIR=/tmp/scr-${SUDO_USER:-$USER}-$SCR_ENV-$SCR_PORT_0
    export EDITOR=$SCR_TMPDIR/editor
    export SCR_VIMRC=$SCR_TMPDIR/vimrc
    export SCR_VIMRUNTIME=$SCR_TMPDIR/vim
    export SCR_SCREENRC=$SCR_TMPDIR/screenrc
    export SCR_SSH_USER_KNOWN_HOSTS=$SCR_TMPDIR/ssh-$SCR_SSH_USER-$SCR_SSH_HOST-known-hosts
    export SCR_USED_OTPS=$SCR_TMPDIR/scr-used-otps
    : ${SCR_SSH_LEVEL:=0}
    export SCR_SSH_LEVEL
    export VIMINIT='source $SCR_VIMRC'
    # for sudo users, if they use vim and SHELL is /bin/false (or similar) then
    # rvim is used (at least on macos)
    export SHELL=$BASH
    # set GIT_SSH so we can ensure SSH_AUTH_SOCK gets set when dealing with git
    # ssh-style URLs, see:
    # https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables#_miscellaneous
    export GIT_SSH=$SCR_TMPDIR/git-ssh
    export SCR_SSH_PROXY_JUMP=$SCR_TMPDIR/ssh-proxy-jump
    #[ -z "$SUDO_USER" ] && rm -f $EDITOR $SCR_VIMRC
    if [ ! -d $SCR_TMPDIR ]; then
      mkdir -p $SCR_TMPDIR
    fi
    version_file="$SCR_TMPDIR/.version"
    if [ "$start" ]; then
      if [ ! -f "$version_file" ]; then
        -tty-echo "force clear cache now, no version file exists ($version_file)"
        clear_cache=1
      else
        old_version=$(<"$version_file")
        if [ "$old_version" != $SCR_VERSION ]; then
          -tty-echo "force clear cache now, detected scrash version change (old=$old_version, new=$SCR_VERSION)"
          clear_cache=1
          rm -f "$version_file"
        fi
      fi
    fi
    if [ $clear_cache = 1 ]; then
      -clear-cache
    fi
    if [ ! -f "$version_file" ]; then
      echo $SCR_VERSION > "$version_file"
    fi
    if [ ! -f $GIT_SSH ]; then
      {
        echo '#!/usr/bin/env bash'
        -shell-init -D
        echo '-sxx-init exec ssh "$@"'
      } > $GIT_SSH
      chmod 755 $GIT_SSH
    fi
  fi
  if [ "$(type -t -- -bashrc)" = function ]; then
    eval -- "$(-bashrc)"
  fi
  fcns=($(compgen -A function "-") screen ssh vim ssh-add scp sftp)
  if [ $declare_mode = 1 ]; then
    declare -f -- ${fcns[*]}
    return
  fi
  export -f -- ${fcns[*]}
  if [ "$start" ]; then
    if [ "$start" = 1 ]; then
      exec bash --norc --noprofile
    else
      exec bash -c -- "-ssh-deserialize-cmd $start"
    fi
  fi
}

# sudo shortcut
# usage: arg1 is the user we want to become (default=root), remaining args are
# the command we want to run as that user
# -s
# -s nobody
# -s nobody whoami
-s() {
  local user=${1:-root} bootstr
  [ $# -gt 0 ] && shift
  [ "$STY" ] && -screen-env
  bootstr=$(-shell-boot-string -p $SCR_PORT -- "$@")
  if [ ! -e $EDITOR ]; then
    # create the editor, might need it under sudo and sudo user will not be
    # able to create it
    vim --version >/dev/null
  fi
  -sxx-scr-server-known-hosts
  # we pass along STY so that -ws calls can properly detect when to run
  # -screen-env
  sudo -H -u $user bash -c "STY='$STY' $bootstr"
}

-ssh-serialize-cmd() {
  local c=("$@")
  declare -p c | openssl enc -a -A
}

-ssh-deserialize-cmd() {
  # b64 is assumed to have been generated from -ssh-serialize-cmd
  local b64="$1" c
  eval -- "$(echo -n $b64 | openssl enc -d -a -A)"
  if [[ "${c[@]}" =~ \$ ]]; then
    # may need to revisit this...
    #eval -- "${c[@]}"
    "${c[@]}"
  else
    "${c[@]}"
  fi
}

-shell-boot-string() {
  local remote_port ssh_level=$SCR_SSH_LEVEL start opts="p:l:" opt OPTIND curl_host=127.0.0.1
  while builtin getopts $opts opt; do
    case $opt in
      (p) remote_port=$OPTARG
        ;;
      (l) ssh_level=$OPTARG
        ;;
    esac
  done
  shift $(($OPTIND-1))
  if [ $# -gt 0 ]; then
    start=$(-ssh-serialize-cmd "$@")
  else
    start=1
  fi
  printf 'eval -- "$(curl --noproxy %s --connect-timeout 5 -S -f -s --compressed http://%s:%s/scr-get-bash-functions?platform=$(uname)\&hostname=$(hostname)\&start=%s\&ssh_level=%s || echo false)"' \
    $curl_host \
    $curl_host \
    $remote_port \
    $start \
    $ssh_level
}

ssh-add() {
  -sxx-init env $FUNCNAME "$@"
}

sftp() {
  -sxx-init env $FUNCNAME "$@"
}

scp() {
  -sxx-init env $FUNCNAME "$@"
}

-sxx-init() {
  if [ ! -f $SCR_SSH_PROXY_JUMP ]; then
    {
      echo '#!/usr/bin/env bash'
      echo '-ssh-proxy-jump "$@"'
    } > $SCR_SSH_PROXY_JUMP
    chmod 755 $SCR_SSH_PROXY_JUMP
  fi
  -ssh-auth-sock "$@"
}

# simulate the functionality of ssh ProxyJump, so we can integrate with the
# ssh-agent OTP logic; place something like this in ssh config file:
#
#   ProxyCommand ${SCR_SSH_PROXY_JUMP} user@jump_host_here dest_host_here
#
# so if we wanted to jump to root@ops.lincware.com first, then get to
# apt.lincware.com we use this:
#
# Host apt.lincware.com
#   ProxyCommand ${SCR_SSH_PROXY_JUMP} root@ops.lincware.com apt.lincware.com
-ssh-proxy-jump() {
  # test: ssh -oProxyCommand="bash -c -- '-ssh-proxy-jump ops apt.lincware.com'" lincdoc@test hostname
  if [ $0 = bash ]; then
    echo "$FUNCNAME: cannot run this here" >&2
    return 1
  fi
  local jump_host=$1 dest_host=$2
  shift 2
  SCR_SSH_EXEC=1 ssh "$@" $jump_host nc $dest_host 22
}

ssh() {
  # link to ssh officially supported command line flags:
  # https://github.com/openssh/openssh-portable/blob/V_9_3_P1/ssh.c#L710
  local SCR_PORT_FORWARD bootstr OPTIND \
    ssh_legal_opts="1246ab:c:e:fgi:kl:m:no:p:qstvxACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy" \
    opt ssh_user_host cmd=(-sxx-init) start=1 rc=0 cmdline_ssh_host \
    h ssh_config=$HOME/.ssh/config prefetch_otps=0 \
    M_flag=0 N_flag=0 S_flag=0
  if [ ${SCR_SSH_EXEC:-0} = 1 ]; then
    cmd+=(exec ssh)
  else
    cmd+=(env ssh)
  fi
  if [[ "$1" =~ --otp=([[:print:]]*) ]]; then
    # see -ssh-proxy-jump
    SCR_PREAUTH_OTP=${BASH_REMATCH[1]}
    if [ ${#SCR_PREAUTH_OTP} = 0 ]; then
      echo "$FUNCNAME: --otp was specified with empty value" >&2
      return 1
    fi
    shift
  fi
  while builtin getopts $ssh_legal_opts opt; do
    #case $opt in
    #  f|N|M|V)
    #    env ssh "$@"
    #    return $?
    #    ;;
    #esac
    cmd+=("-$opt")
    [ "$OPTARG" ] && cmd+=("$OPTARG")
    # if -N is given, still allow for forwarding SCR_PORT but skip bootstr
    # (integration tests use this with a ssh control master)
    [ $opt = M ] && M_flag=1
    [ $opt = N ] && N_flag=1
    [ $opt = S ] && S_flag=1
    [[ $opt = o && ( "$OPTARG" =~ ^ControlPath ) ]] && S_flag=1
    [[ $opt = o && ( "$OPTARG" =~ ^ControlMaster ) ]] && M_flag=1
    [ $opt = F ] && ssh_config="$OPTARG"
  done
  # after this shift, the ssh user@host should be left in $1 (assuming an
  # user@host was provided on the command line, which is most of the time)
  [ $OPTIND -gt 1 ] && shift $(($OPTIND-1))
  ssh_user_host="$1"
  cmdline_ssh_host=${ssh_user_host##*@}
  if [ "$ssh_user_host" ]; then
    shift
    if [ $# -eq 0 ]; then
      cmd+=(-t)
    fi
    SCR_PORT_FORWARD=$(( $RANDOM % 5000 + 56100 ))
    [ "$STY" ] && -screen-env
    cmd+=(
      -oExitOnForwardFailure=yes
      -R$SCR_PORT_FORWARD:127.0.0.1:$SCR_PORT
      "$ssh_user_host"
    )
    if [[ $M_flag = 1 || ( $M_flag = 0 && $S_flag = 0 ) ]]; then
      if [ -f "$ssh_config" ] && grep -q -E '^ *ProxyCommand .*\{SCR_SSH_PROXY_JUMP\}.* '$cmdline_ssh_host'$' "$ssh_config"; then
        prefetch_otps=1
        -prefetch-otps
      fi
    fi
    if [ $N_flag = 0 ]; then
      if [ "$RA_SSH_USE_EVAL" = 1 -o "$RA_AGENT_ID" ]; then
        # we are running remoteadmin shell - if any of the args begin with $'
        # then we assume we need to prepend an eval; need to drop this hack in
        # remoteadmin 6
        for opt in "$@"; do
          if [ ${opt:0:2} = "$'" ]; then
            set -- eval -- "$@"
            break
          fi
        done
      fi
      bootstr=$(-shell-boot-string -l $(($SCR_SSH_LEVEL+1)) -p $SCR_PORT_FORWARD -- "$@")
      cmd+=(exec bash -c "'"$bootstr"'")
      h=$cmdline_ssh_host
      [ "$SSH_STY_LBL" ] && h=$SSH_STY_LBL
      [ "$STY" ] && printf "\033k$h\033\134" >/dev/tty
    else
      # display for forwarded port, might have a use for this someday
      printf "SCR_PORT_FORWARD=%s\n" $SCR_PORT_FORWARD
    fi
  fi
  if "${cmd[@]}"; then
    :
  else
    rc=$?
  fi
  if [ $N_flag = 0 ]; then
    [ "$STY" ] && printf "\033k${HOSTNAME}\033\134" >/dev/tty
  fi
  if [ $prefetch_otps = 1 -a -p "$SCR_OTP_CACHE_FIFO" ]; then
    rm -f $SCR_OTP_CACHE_FIFO
  fi
  return $rc
}

-set-clipboard() {
  local f="${1:-/dev/stdin}" stripTrailingReturn=0
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f" >&2
    return 1
  fi
  if [ "$f" = /dev/stdin ]; then
    stripTrailingReturn=1
  fi
  -ws /scr-set-clipboard?stripTrailingReturn=$stripTrailingReturn --data-binary @"$f"
}

#
# pre-fetch OTPs for the current shell level ($SHLVL), and also for the next
# lower shell level. Use a named pipe ($SCR_OTP_CACHE_FIFO) to pass OTPs from
# the current shell level to the lower one. This function should only be called
# by the ssh function.
#
# Primary use case: an ssh session which is configured to use ProxyJump, which
# ssh spawns a process to do the jump
-prefetch-otps() {
  # arbitrarily default num_otps=6
  local num_otps=6 dest_shlvl=$(($SHLVL+1))
  if [ "${FUNCNAME[1]}" != ssh ]; then
    echo "$FUNCNAME: expected caller to be ssh" >&2
    return 1
  fi
  -fetch-otps $num_otps
  export SCR_OTP_CACHE_FIFO=$(mktemp -u).$dest_shlvl
  rm -f $SCR_OTP_CACHE_FIFO
  if [ -e $SCR_OTP_CACHE_FIFO ]; then
    echo "$FUNCNAME: could not remove $SCR_OTP_CACHE_FIFO" >&2
    return 1
  fi
  if ! mkfifo $SCR_OTP_CACHE_FIFO; then
    echo "$FUNCNAME: mkfifo on $SCR_OTP_CACHE_FIFO failed" >&2
    return 1
  fi
  # use half of the fetched OTPs for current shell level, and half for the next
  # lower level
  otps="$(
    for otp in ${SCR_OTP_CACHE[*]:0:$num_otps/2}; do
      echo $otp
    done
  )"
  echo "$otps" >$SCR_OTP_CACHE_FIFO &
  SCR_OTP_CACHE=(${SCR_OTP_CACHE[*]:$num_otps/2})
}

-used-otp() {
  local otp="$1"
  if [ "$SUDO_USER" ]; then
    echo "$FUNCNAME warning: skipping due to sudo session in effect" >&2
    return
  fi
  if [ ! -f $SCR_USED_OTPS ]; then
    touch $SCR_USED_OTPS
  fi
  if [ "$otp" ] && ! grep -q "$otp" $SCR_USED_OTPS; then
    echo "$otp" >> $SCR_USED_OTPS
  fi
}

-fetch-otps() {
  # note: otp_max_lifetime should be a few seconds less than OTP_MAX_LIFETIME
  # in OtpCache.js
  local count=${1:-1} otp_max_lifetime=17 i now=$(date +%s) otp_line subshell expiration
  if ! [[ "$count" =~ ^[0-9]+$ ]]; then
    echo "$FUNCNAME: illegal count: $count" >&2
    return 1
  fi
  # create the OTP cache if it does not exist
  if ! compgen -v SCR_OTP_CACHE >/dev/null; then
    -log "creating SCR_OTP_CACHE[$SHLVL:$BASH_SUBSHELL] $(hostname)"
    SCR_OTP_CACHE=()
  fi
  # load SCR_OTP_CACHE into positional params for easier access
  set -- ${SCR_OTP_CACHE[*]}
  if [ -p "$SCR_OTP_CACHE_FIFO" ] && [[ "$SCR_OTP_CACHE_FIFO" =~ .+\.([0-9]+)$ ]]; then
    local fifo_shlvl=${BASH_REMATCH[1]}
    if [ $SHLVL = $fifo_shlvl ]; then
      {
        while true; do
          read
          if [ -z "$REPLY" ]; then
            break
          fi
          set -- "$@" $REPLY
        done
      } <$SCR_OTP_CACHE_FIFO
      -log "loaded $# OTPs from $SCR_OTP_CACHE_FIFO[$SHLVL:$BASH_SUBSHELL]"
      unset SCR_OTP_CACHE_FIFO
      rm -f $SCR_OTP_CACHE_FIFO
    fi
  fi
  # remove any invalid OTPs from the cache if:
  # 1. they may have already expired
  # 2. they may have been created in a parent process of a bash command
  # substitution (command substitution will inherit SCR_OTP_CACHE, but any
  # changes to it inside the command substitution are not seen by parent
  # shell); note that BASH_SUBSHELL increases by 1 inside command substitution,
  # but SHLVL does not
  # 3. they may have been already used, if they are present in $SCR_USED_OTPS
  for ((i=$#;i>0;i--)); do
    #if ! [[ ${!i} =~ ^([0-9]+):([0-9]+):([[:print:]]+)$ ]]; then
      #echo "$FUNCNAME: invalid cache value: ${!i}" >&2
      #return 1
    #fi
    #subshell=${BASH_REMATCH[1]}
    ##expiration=${!i%%:*}
    #expiration=${BASH_REMATCH[2]}
    IFS=: read -a otp_line <<<"${!i}"
    subshell=${otp_line[0]}
    expiration=${otp_line[1]}
    if [ $BASH_SUBSHELL -gt $subshell ]; then
      -log "remove otp due to subshell mismatch ($BASH_SUBSHELL>$subshell) at index $i:${!i}"
    elif [ $(($now-$expiration)) -ge $otp_max_lifetime ]; then
      -log "expiring ($expiration) otp at index $i:${!i}"
    elif [ "$otp" ] && grep -q "$otp" $SCR_USED_OTPS 2>/dev/null; then
      -log "remove already used otp at index $i:${!i}"
    else
      continue
    fi
    set -- ${@:1:$i-1} ${@:$i+1}
  done
  -log "SCR_OTP_CACHE[$SHLVL:$BASH_SUBSHELL] now:$#:$*"
  # if the cache does not have enough OTP's, then go get as many as needed
  if [ $count -gt $# ]; then
    set -- $@ $(-ws-set-otp $(($count-$#)))
    -log "SCR_OTP_CACHE[$SHLVL:$BASH_SUBSHELL] now:$#:$*"
  fi
  if [ ${otp+x} ]; then
    # load the first OTP into "otp" variable, which should specifically NOT
    # local to this function, and should be declared by the caller
    otp=${1##*:}
    shift
    -log "SCR_OTP_CACHE[$SHLVL:$BASH_SUBSHELL] now:$#:$*"
  else
    echo "$FUNCNAME: warning: caller otp variable was not detected" >&2
  fi
  # restore our cache from positional params
  SCR_OTP_CACHE=($*)
}

-ws-set-otp() {
  local otp erase_eol='\033[0K' otp_length=6 count=${1:-1} i otp_line now=$(date +%s) otp_encoded
  if [ "${FUNCNAME[1]}" != -fetch-otps ]; then
    echo "$FUNCNAME: caller should always be -fetch-otps" >&2
    return 1
  fi
  if [ "$SCR_PREAUTH_OTP" ]; then
    echo "$SCR_PREAUTH_OTP"
    unset SCR_PREAUTH_OTP
    return
  fi
  if otp_line=$(-ws /scr-set-otp?count=$count); then
    if [ ${#otp_line} -eq 0 ]; then
      # using printf to display the prompt rather than "read -p ..." so that
      # this can work when running inside vim
      printf "${erase_eol}OTP[$count:$SHLVL:${FUNCNAME[*]:2}]? " >/dev/tty
      read -rn $(($count*$otp_length)) otp_line </dev/tty
    fi
  else
    echo "$FUNCNAME: failed to acquire OTP (on host $(hostname))" >&2
    return 1
  fi
  for ((i=0;i<$count;i++)); do
    otp=${otp_line:$i*$otp_length:$otp_length}
    otp_encoded=$(echo -E -n "$otp" | openssl enc -a -A)
    printf "%s:%s:%s\n" $(($BASH_SUBSHELL-1)) $now $otp_encoded
  done
}

# fetches clipboard contents
-get-clipboard() {
  -ws -o /scr-get-clipboard --compressed "$@"
}

-md5() {
  local f="${1:-/dev/stdin}"
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f" >&2
    return 1
  fi
  local md5=$(openssl md5 -hex "$f")
  # md5 will look something like this:
  # MD5(somefile)= 7f851736b8f86d8ee734a5d94bedf2f7
  # remove the prefix
  md5=${md5##*= }
  # force to lowercase: OS X cannot do "md5=${md5,,}" so use tr
  echo $md5 | tr "[:upper:]" "[:lower:]"
}

#
# pick 1 line from a list. positional parameters:
#
#   intro_label: the label to display before presenting the list
#
#   pick_list: a multiline string with the choices to be given to user
#
#   use_idx: if 1, this script outputs the index number of the user's choice,
#   else we output the chosen line from pick_list
#
# example usage: 
#
#   file=$(-pick-something "Pick a file:" "$(find $logdir -type f | sort)")
#   [ -f "$file" ] && lwsa_view_file "$file"
#
# the user selected item from the original list is echoed to stdout
#
# return code: 0 user picked a valid entry from the list; 1 user did not choose
# anything; 2 user gave some other bogus choice
#
-pick-something() {
  local tty=/dev/tty intro_label="$1" pick_list="$2" use_idx="$3" i l c
  local -a pick_array
  IFS=$'\n' read -d '' -a pick_array <<< "$pick_list"
  local indexes=${!pick_array[@]}
  local n=${#pick_array[@]}
  pick_list=$(
    echo "$intro_label"
    for ((i=0; i<$n; i++)); do
      l=${pick_array[$i]}
      printf "%s. %s\n" $(($i+1)) "$l"
    done
  )
  l=$(tput lines)
  if [ $((${#pick_array[@]}-2)) -gt $l ]; then
    less <<< "$pick_list" >$tty
  else
    echo "$pick_list" >$tty
  fi
  read -p "Enter choice: " c
  [ -z "$c" ] && return 1
  ! [[ "$c" =~ ^[0-9]+$ ]] && return 2
  c=$(($c-1))
  if echo $indexes | grep -q -w -- "$c"; then
    if [ "$use_idx" = 1 ]; then
      echo $c
    else
      echo "${pick_array[$c]}"
    fi
  else
    return 2
  fi
}

# we use perl to handle proxy connections back to the scrash server; this bash
# function acts as the perl source
-perl-proxying-subroutines() {
echo '
use IO::Socket::INET;
use IO::Select;

sub create_proxy_socket {
  my ($SCR_PORT,$otp,$connect_dest)=@_;

  my $socket=IO::Socket::INET->new(
    Proto=>"tcp",
    Blocking=>1,
    PeerAddr=>"127.0.0.1",
    PeerPort=>$SCR_PORT) or die "Cannot create socket - $IO::Socket::errstr\n";
  $socket->autoflush(1);

  # send request headers
  $socket->send(sprintf("CONNECT %s HTTP/1.0\r\n",$connect_dest));
  $socket->send(sprintf("X-Scrash-Otp: %s\r\n",$otp));
  $socket->send("\r\n");

  # read response headers
  chomp(my $status_line=readline($socket));
  printf STDERR "%s\n",$status_line;
  while (chomp(my $hdr=readline($socket))) {
    if ($hdr eq "\r") {
      last;
    }
    #printf STDERR "header:<%s>\n",$hdr;
  }
  # something weird going on if we call -used-otp before receiving the response
  # headers; test cases will fail, and not sure why
  system("/usr/bin/env","bash","-c","--","-used-otp $otp");
  return $socket;
}

# connect socket bi-directionally to stdin/stdout
sub bi_directional_pipe {
  my ($stdin,$stdout,$socket)=@_;
  $|=1;
  my $select=IO::Select->new();
  $select->add($stdin);
  $select->add($socket);
  my $read_size=4096;
  while (1) {
    my @ready=$select->can_read;
    for my $fh (@ready) {
      if ($fh==$stdin) {
        my $input;
        my $bytes=sysread($stdin,$input,$read_size);
        if (!defined $bytes || $bytes==0) {
          exit 0;
        }
        syswrite($socket,$input,$bytes);
      } elsif ($fh==$socket) {
        my $output;
        my $bytes=sysread($socket,$output,$read_size);
        if (!defined $bytes || $bytes==0) {
          exit 0;
        }
        syswrite($stdout,$output,$bytes);
      }
    }
  }
}
'
}
#
# take a ssh|scp|sftp command and add arguments to it such that it can
# authenticate with ssh-agent running on the scrash server
#
-ssh-auth-sock() {
  local SSH_AUTH_SOCK umask arg i rc pid perl_code start=$SECONDS elapsed
  # warning: on Ubuntu 8 when using ProxyJump, it was necessary to initialize
  # otp to a null string in order for -fetch-otps to detect the variable exists
  local otp=''
  if [ ${SCR_SSH_AUTH_SOCK_SKIP_OPTIMIZATION:-0} = 1 ]; then
    echo "$FUNCNAME: force skip optimization" >&2
  else
    if [ -S "$SCR_SSH_AUTH_SOCK" ]; then
      # optimization: skip proxy ssh auth socket logic because we are local to
      # the scrash server
      SSH_AUTH_SOCK=$SCR_SSH_AUTH_SOCK "$@"
      return $?
    fi
  fi
  if [ "$1" = env ]; then
    # check options for ControlPath/ControlMaster. If only ControlPath is
    # detected we can apply an optimization and skip using an OTP
    local orig_opts=("$@") ssh_opts=("${@:3}") opts="o:SM" opt OPTIND OPTERR=0 has_control_path=0 has_control_master=0
    set -- "${ssh_opts[@]}"
    while builtin getopts $opts opt; do
      case $opt in
        (o)
          [[ "$OPTARG" =~ ^ControlPath ]] && has_control_path=1
          [[ "$OPTARG" =~ ^ControlMaster ]] && has_control_master=1
          ;;
        (M) has_control_master=1
          ;;
        (S) has_control_path=1
          ;;
      esac
    done
    set -- "${orig_opts[@]}"
    if [ $has_control_master = 0 -a $has_control_path = 1 ]; then
      echo "$FUNCNAME: optimization for ControlPath, skip OTP" >&2
      "$@"
      return $?
    fi
  fi
  if ! -fetch-otps; then
    return 1
  fi
  if [ -z "$otp" ]; then
    echo "$FUNCNAME: failed to acquire otp at SHLVL: $SHLVL" >&2
    return 1
  fi
  umask=$(umask)
  umask 077
  if ! SSH_AUTH_SOCK=$(mktemp -u); then
    echo "$FUNCNAME: failed to create temp $SSH_AUTH_SOCK" >&2
    umask $umask
    return 1
  fi
  perl_code=$(-perl-proxying-subroutines)'
my ($SCR_PORT,$otp,$connect_dest,$SSH_AUTH_SOCK)=@ARGV;
# create a 1-time use ssh-agent unix domain socket
sub create_unix_domain_socket {
  my ($SSH_AUTH_SOCK)=@_;
  my $svr=IO::Socket::UNIX->new(
    Listen=>1,
    Local=>$SSH_AUTH_SOCK,
  ) || die "IO::Socket error creating svr: $IO::Socket::errstr\n";
  my $socket=$svr->accept();
  unlink $SSH_AUTH_SOCK;
  return $socket;
}
my $socket0=create_unix_domain_socket($SSH_AUTH_SOCK);
my $socket1=create_proxy_socket($SCR_PORT,$otp,$connect_dest);
bi_directional_pipe($socket0,$socket0,$socket1);
'
  perl <(echo "$perl_code") $SCR_PORT "$otp" SCR_SSH_AUTH_SOCK_REQUEST $SSH_AUTH_SOCK &
  pid=$!
  until [ -S $SSH_AUTH_SOCK ]; do
    sleep 0.1
    let elapsed=$SECONDS-$start || true
    if [ $elapsed -ge 10 ]; then
      echo "WARNING: $FUNCNAME failed to detect SSH_AUTH_SOCK, you may need to kill perl process $pid" >&2
      break
    fi
  done
  SSH_AUTH_SOCK=$SSH_AUTH_SOCK "$@"
  rc=$?
  rm -f $SSH_AUTH_SOCK
  umask $umask
  if kill -0 $pid 2>/dev/null; then
    kill $pid
  fi
  return $rc
}

# this function is used for ssh connections back to the scrash server
-ssh-proxy-connect() {
  local otp="$1" connect_dest=$2 perl_code
  perl_code=$(-perl-proxying-subroutines)'
my ($SCR_PORT,$otp,$connect_dest)=@ARGV;
my $socket=create_proxy_socket($SCR_PORT,$otp,$connect_dest);
bi_directional_pipe(\*STDIN,\*STDOUT,$socket);
'
  exec perl <(echo "$perl_code") $SCR_PORT "$otp" $connect_dest
}

-sxx-scr-server-known-hosts() {
  if [ ! -f "$SCR_SSH_USER_KNOWN_HOSTS" -o ! -s "$SCR_SSH_USER_KNOWN_HOSTS" ]; then
    -ws /scr-ssh-user-known-hosts > "$SCR_SSH_USER_KNOWN_HOSTS"
  fi
}

# run one of ssh, sftp, scp, etc. connecting back to the scrash server
-sxx-scr-server() {
  local sxx=$1 otp='' cmd
  shift
  if -fetch-otps 2; then
    -sxx-scr-server-known-hosts
    cmd=(
      $sxx
      #-oLogLevel=DEBUG3
      -oConnectTimeout=10
      -oUserKnownHostsFile="$SCR_SSH_USER_KNOWN_HOSTS"
      -oProxyCommand="bash -c -- \"-ssh-proxy-connect $otp $SCR_SSH_HOST:22\""
      #-oProxyCommand="nc -X connect -x 127.0.0.1:$SCR_PORT localhost-otp-$otp 22"
    )
    for arg in "$@"; do
      # handle filenames with spaces
      cmd+=("${arg// /\\ }")
    done
    "${cmd[@]}"
  else
    return 1
  fi
}

-upload() {
  local upload_file="$1"
  if [ "$upload_file" ]; then
    shift
    [ $# -eq 0 ] && set -- .
    -sxx-scr-server scp $SCR_SSH_USER@$SCR_SSH_HOST:"$upload_file" "$@"
  else
    -sxx-scr-server sftp $SCR_SSH_USER@$SCR_SSH_HOST
  fi
}

-download() {
  local f
  if [ $# -eq 0 ]; then
    echo "$FUNCNAME: missing file(s) to be downloaded" >&2
    return 1
  fi
  for f in "$@"; do
    if [ ! -e "$f" ]; then
      echo "$FUNCNAME: no such file: $f" >&2
      return 1
    fi
  done
  -sxx-scr-server scp "$@" $SCR_SSH_USER@$SCR_SSH_HOST:/tmp
}

# -pw retrieves a password based on the given key, which can be supplied as arg
# 1 or passed in stdin
#
# limitation: password cannot contain a colon because that is assumed to be the
# delimiter here
-pw() {
  local opt OPTIND search_key pw_line pw n index=-1 split_char=':' b64=0 pw_file="$SCR_PASSWORD_FILE" found=0
  while builtin getopts "hbi:p:" opt; do
    case $opt in
      (h)
        echo "usage: $FUNCNAME [-hb][-i index][-p password_file] search_key"
        echo "-h: this help"
        echo "-b: base64 encode the result"
        echo "-i: for each matched line, return this index value of the line when it is split by \"$split_char\""
        echo "-p: specify an alternate password file, default=$pw_file"
        return
        ;;
      (b)
        b64=1
        ;;
      (i)
        # for each line found, within that line what part of the line do we want?
        # default is the last index
        index=$OPTARG
        ;;
      (p)
        pw_file="$OPTARG"
        ;;
    esac
  done
  shift $(($OPTIND-1))
  search_key="$1"
  shift
  if [ $SCR_SSH_LEVEL = 0 ]; then
    if [ ! -r "$pw_file" ]; then
      echo "$FUNCNAME: could not read password file: $pw_file" >&2
      return 1
    fi
    while read -r pw_line; do
      found=1
      IFS="$split_char" builtin read -r -a pw_line <<<"$pw_line"
      if [ "$index" ]; then
        let n=$index || true
      else
        let n=${#pw_line[*]}-1
      fi
      pw="${pw_line[$n]}"
      if [ $b64 = 0 ]; then
        echo "$pw"
      else
        printf "%s\n" $(printf %s "$pw" | openssl enc -a -A)
      fi
    done < <(gpg -qd "$pw_file" | grep "$search_key")
    if [ $found = 0 ]; then
      return 1
    fi
  elif -ws -o /scr-get-password --data-urlencode "searchKey=$search_key" --data-urlencode "b64=$b64"  --data-urlencode "index=$index" --data-urlencode "pwFile=$pw_file" "$@"; then
    :
  else
    echo "$FUNCNAME: problem with OTP" >&2
    return 1
  fi
}

#
# This function greps "ps" output for a given string (case insensitively);
# similar to pgrep
#
# If stdout is the tty, the output highlights the search string in red
#
-psg() (
  local ps_cmd ps_output search_string os=$(uname) i l m matched x n=0 ATTR_RED='\x1b[1;31m' ATTR_CLEAR='\x1b[0m' opts="wkhep" opt OPTIND wb1 wb2 pid kill_signal kill_clause edit_mode=0 tmpfile only_pids=0
  shopt -s nocasematch
  while builtin getopts $opts opt; do
    case $opt in
      (h) echo "usage: $FUNCNAME [-hwk] search_string"
        echo "-h      this help"
        echo "-w      match search_string on word boundary"
        echo "-k      output kill statements for matched pids"
        echo "-e      edit the matched output (meant to be used simultaneously with -k)"
        echo "-p      output pids only"
        return
        ;;
      (w)
        # match on word boundary: man re_format
        wb1="[[:<:]]"
        wb2="[[:>:]]"
        ;;
      (k)
        kill_signal=TERM
        ;;
      (e)
        edit_mode=1
        ;;
      (p)
        only_pids=1
        ;;
    esac
  done
  if [ "$kill_signal" -a $only_pids = 1 ]; then
    echo "$FUNCNAME: incompatible options" >&2
    return 1
  fi
  [ $OPTIND -gt 1 ] && shift $(($OPTIND-1))
  search_string="$*"
  case $os in
    (OpenBSD|Darwin)
      ps_cmd="ps -jAwww"
      ;;
    (Linux)
      ps_cmd="ps -fewww"
      ;;
    (*)
      echo "$FUNCNAME: no support for $os" >&2
      return 1
      ;;
  esac
  ps_output="$($ps_cmd)"
  output=""
  while read l; do
    matched=0
    n=$(($n+1))
    if [ $only_pids = 0 ] && [ $n = 1 -o -z "$search_string" ]; then
      if [ $n = 1 -a "$kill_signal" ]; then
        output+="#                           "
      fi
      output+="$l"$'\n'
      if [ $n = 1 -a "$kill_signal" ]; then
        output+="kill_signal=$kill_signal"$'\n'
      fi
      continue
    elif [[ "$l" =~ $ps_cmd ]]; then
      continue
    fi
    pid=""
    kill_clause=""
    # find all occurrences of the search string and highlight them (if output
    # is to a tty)
    while [[ "$l" =~ $wb1($search_string)$wb2 ]]; do
      m="${BASH_REMATCH[1]}"
      if [ -z "$pid" ] && [ "$kill_signal" -o $only_pids = 1 ]; then
        if ! [[ "$l" =~ ^[^[:blank:]]+[[:blank:]]+([0-9]+) ]]; then
          echo "$FUNCNAME: could not acquire pid: $l" >&2
          return 1
        fi
        pid=${BASH_REMATCH[1]}
        if [ $only_pids = 1 ]; then
          output+=$pid$'\n'
          break
        fi
        if [ "$kill_signal" ]; then
          printf -v kill_clause 'kill -$kill_signal %6s # ' $pid
          output+="$kill_clause"
        fi
      fi
      matched=1
      # x will be all text leading up to the matched search string
      x="${l%%$m*}"
      # compute the index of the search string in the line
      i=${#x}
      output+="${l:0:$i}"
      if [ -t 1 -a $edit_mode = 0 ]; then
        output+=$(printf "$ATTR_RED%s$ATTR_CLEAR" "$m")
      else
        output+="$m"
      fi
      l="${l:$i+${#m}}"
    done
    [ $matched = 1 -a $only_pids = 0 ] && output+="$l"$'\n'
  done <<< "$ps_output"

  # remove the final \n
  output=$(echo "$output")
  # display the output; if output has more lines than the terminal has rows
  # then use "less" to view it
  term_lines=$(tput lines)
  IFS=$'\n' output_array=($output)
  if [ $edit_mode = 1 ]; then
    tmpfile=$(mktemp)
    echo "$output" > $tmpfile
    vim $tmpfile
    if [ "$kill_signal" ]; then
      read -p "source $tmpfile [yn, default=n]? " yn
      if [ "$yn" = y ]; then
        source $tmpfile
      fi
    fi
    rm -f $tmpfile
  elif [ ${#output_array[@]} -gt $term_lines ]; then
    less <<< "$output" >/dev/tty
  else
    echo "$output"
  fi
)
