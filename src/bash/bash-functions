# vim:filetype=bash

-add-path() {
  while [ $# -gt 0 ]; do
    [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]] && PATH="$1:$PATH"
    shift
  done
}

-vars() {
  {
    set | grep ^EDITOR
    set | grep ^SCR
    set | grep ^STY
    set | grep ^VIM
  } | sort
}

-clear-cache() {
  if [[ "$SCR_TMPDIR" =~ ^/tmp/ ]]; then
    rm -rf $SCR_TMPDIR/*
    echo "cleaned out $SCR_TMPDIR"
  fi
}

-debug-ts() {
  echo "${FUNCNAME[*]}:$@:$(date +%s)" >> $SCR_TMPDIR/a
}

-random-string() {
  local length=${1:-16} r="" c
  while [ ${#r} -lt $length ]; do
    read -n 1 c
    r+=$c
  done < <(LC_ALL=C tr -dc A-Za-z0-9 </dev/urandom || true)
  echo $r
}

-pick-sty() {
  local stys pick_sty pick_sty_line session_id curr_sty=${STY:-no_such_sty_exists}
  # make a pick list of available session ids
  stys=$(
    while read l; do
      if [[ "$l" =~ ^[[:blank:]]*([0-9]+\.[^[:blank:]]+)[[:blank:]]+([[:print:]]+) ]]; then
        pick_sty=${BASH_REMATCH[1]}
        pick_sty_status=${BASH_REMATCH[2]}
        echo "$pick_sty $pick_sty_status"
      fi
    done < <(env screen -ls | grep -v $curr_sty)
  )
  if [ -z "$stys" ]; then
    echo "No screen sessions detected." >/dev/tty
    return 0
  fi
  if ! pick_sty_line=$(-pick-something "Resume which session?" "$stys"); then
    return 1
  fi
  if [[ $pick_sty_line =~ ^([0-9]+\.([-[:alnum:]]+)) ]]; then
    pick_sty=${BASH_REMATCH[1]}
    session_id=${BASH_REMATCH[2]}
    echo $session_id
  else
    echo "$FUNCNAME: no match for pick_sty_line: $pick_sty_line" >&2
    return 1
  fi
}

#
# call within gnu screen to update important environment variables; in
# particular, this must be called prior to any call to -ws or -ssh
-screen-env() {
  local opts="uS:p" opt OPTIND update=0 v SCR_UPDATEABLE="SCR_PORT SSH_AUTH_SOCK" file_prefix=scr-sty-env- echo_port=0
  # keep STY local so we don't pollute parent shell when reconnecting to a gnu
  # screen session
  local STY=$STY
  while builtin getopts $opts opt; do
    case $opt in
      (u) update=1
        ;;
      (S) STY=$OPTARG
        ;;
      (p) echo_port=1
        ;;
    esac
  done
  if [ -z "$STY" ]; then
    echo "$FUNCNAME: no value for STY" >&2
    return 1
  fi
  local session_id=${STY##*.}
  local SCR_STY_ENV=$SCR_TMPDIR/$file_prefix$session_id
  if [ -z "$SUDO_USER" ]; then
    local old_env old_env_id
    for old_env in $SCR_TMPDIR/$file_prefix*; do
      if [[ $old_env =~ $file_prefix([:alnum:].*) ]]; then
        old_env_id=${BASH_REMATCH[1]}
        if ! screen -ls | grep -q $old_env_id; then
          rm -f $old_env
          echo "removed old fifo: $old_env" >&2
        fi
      fi
    done
  fi
  if [ $update = 1 ]; then
    # update critical environment variables
    if {
      for v in $SCR_UPDATEABLE; do
        if [ "${!v}" ]; then
          printf "%s='%s'\n" $v ${!v}
        fi
      done
    } > $SCR_STY_ENV; then
      printf "%s: successful update on %s:\n%s\n" $FUNCNAME $session_id "$(<$SCR_STY_ENV)" >&2
      return
    else
      echo "$FUNCNAME: failed to write to $SCR_STY_ENV" >&2
      return 1
    fi
  fi
  if [ ! -e $SCR_STY_ENV ]; then
    touch $SCR_STY_ENV
  fi
  if ! source $SCR_STY_ENV; then
    echo "$FUNCNAME: failed to load data from $SCR_STY_ENV" >&2
    return 1
  fi
  if [ $echo_port = 1 ]; then
    echo $SCR_PORT
  fi
}

# wrapper around gnu screen
screen() {
  local i i2 next_arg rcfile session_id_prefix="scr" session_id opt cmd=() env=() esc=^Aa update=0 command=0 skip=0
  for ((i=1;i<=$#;i++)); do
    i2=$((i+1))
    next_arg="${!i2}"
    opt="${!i}"
    skip=0
    case $opt in
      (--generate-session-id)
        printf "%s-%s" $session_id_prefix $(-random-string 4)
        return
        ;;
      (-ls|-list|-wipe|-Q|-D|-R)
        env screen "$@"
        return $?
        ;;
      (-X)
        if [ $update = 1 ]; then
          if ! -screen-env -S $session_id -u; then
            return $?
          fi
        fi
        env screen "$@"
        return $?
        ;;
      (-r)
        if [[ "$next_arg" =~ ^[[:alnum:]] ]]; then
          session_id=$next_arg
        else
          if ! session_id=$(-pick-sty); then
            return 1
          fi
        fi
        if [[ $session_id =~ ^$session_id_prefix ]]; then
          if ! -screen-env -S $session_id -u; then
            return $?
          fi
        fi
        set -- "${@:1:i-1}" -r $session_id "${@:i+1}"
        cmd+=("$@")
        env screen "${cmd[@]}"
        return $?
        ;;
      (-u)
        set -- "${@:1:i-1}" "${@:i+1}"
        let i-=1
        skip=1
        update=1
        ;;
      (-S)
        session_id=$next_arg
        ;;
      (-c)
        rcfile=$next_arg
        ;;
    esac
    [ $skip = 0 ] && cmd+=("$opt")
  done
  #if ! [[ "${cmd[@]}" =~ -S\ +[[:alnum:]] ]]; then
  if ! [ "$session_id" ]; then
    session_id=$($FUNCNAME --generate-session-id)
    cmd+=(-S $session_id)
  fi
  if [ -z "$rcfile" -a "$session_id" ]; then
    rcfile=$SCR_SCREENRC
    if [ ! -f $rcfile ]; then
      if ! -screenrc > $rcfile; then
        return $?
      fi
    fi
    env+=(SCR_STY_LAST_UPDATE="$(date)")
    cmd+=(-c $rcfile)
  fi
  if [ "$SSH_TTY" ]; then
    esc=^Ee
  fi
  [ $TERM = dumb ] && TERM=screen
  # strip off "screen." prefix from $TERM to avoid "$TERM too long" issue
  cmd+=(-T ${TERM#screen.} -ln -e$esc "$@")
  env "${env[@]}" screen "${cmd[@]}"
}

-ws() {
  [ "$STY" ] && -screen-env
  local base_url=http://127.0.0.1:$SCR_PORT endpoint=$1 url rc
  shift
  printf -v url "%s%s" $base_url $endpoint
  set -- "$@" "$url"
  curl --noproxy 127.0.0.1 -f -S -s "$@"
  rc=$?
  if [ $rc -gt 0 ]; then
    echo "curl failed with arguments: $@" >&2
    echo "stack trace: ${FUNCNAME[*]}" >&2
  fi
  return $rc
}

-ws-about() {
  -ws /scr-about -f -S "$@"
}

-ws-hello-world() {
  -ws /scr-hello-world -f -S "$@"
}

# runs a bash command in gnu screen, waiting for the command to finish
-screen-pipe() (
  local stdin stdout stderr rcfifo fifo eof_stdout=0 eof_stderr=0 opts="uS:" opt OPTIND cmd=() pids=()
  printf -v stdin "%s/sty-stdin-fifo" $SCR_TMPDIR
  printf -v stdout "%s/sty-stdout-fifo" $SCR_TMPDIR
  printf -v stderr "%s/sty-stderr-fifo" $SCR_TMPDIR
  printf -v rcfifo "%s/sty-rc-fifo" $SCR_TMPDIR
  while builtin getopts $opts opt; do
    case $opt in
      (u)
        cmd+=(-u)
        ;;
      (S)
        cmd+=(-S $OPTARG)
        ;;
    esac
  done
  # remaining args are the command to be run in the new screen window we are
  # about to create
  shift $(($OPTIND-1))
  cmd+=(-X screen bash -c -- "exec 0<$stdin 1>$stdout 2>$stderr 3>$rcfifo bash")
  for fifo in $stdin $stdout $stderr $rcfifo; do
    if [ ! -e $fifo ]; then
      mkfifo $fifo
    fi
  done
  {
    c=("$@")
    declare -p c
    echo 'if [[ "${c[@]}" =~ \$ ]]; then'
    echo '  eval -- "${c[@]}"'
    echo 'else'
    echo '  "${c[@]}"'
    echo 'fi'
    echo 'rc=$?'
    echo 'echo $rc >&3'
    echo 'exit'
  } >$stdin &
  pids+=($!)
  while :; do
    read -d '' <$stdout || eof_stdout=1
    [ "$REPLY" ] && echo "$REPLY"
    [ $eof_stdout = 1 ] && break
  done &
  pids+=($!)
  while :; do
    read -d '' <$stderr || eof_stderr=1
    [ "$REPLY" ] && echo "$REPLY" >&2
    [ $eof_stderr = 1 ] && break
  done &
  pids+=($!)
  trap "kill -KILL ${pids[*]}; trap - INT; exit 1" INT
  screen "${cmd[@]}"
  read -d '' rc <$rcfifo || true
  return $rc
)

-screen-shot() {
  local f t
  if [ -z "$STY" ]; then
    echo "$FUNCNAME: not running gnu screen" >&2
    return 1
  fi
  f=$(mktemp)
  t=$RANDOM
  if [ ! -e $EDITOR ]; then
    v --version >/dev/null
  fi
  env screen -X hardcopy $f
  env screen -t $t sh -c "$EDITOR -c \"set nonumber\" $f; rm $f"
  env screen -X select $t
}

vim() {
  if [ -z "$EDITOR" ]; then
    echo "$FUNCNAME: EDITOR is not set" >&2
    return 1
  fi
  local d=$(dirname $EDITOR)
  [ ! -d $d ] && mkdir -p $d
  if [ ! -e $EDITOR ]; then
    local p='#!/usr/bin/env bash\n[ "$1" = "--version" ] && exec vim "$@"\n%s\n-shell-init\nexec vim "$@"\n'
    #local url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
    #eval "$(curl -S -f -s --compressed $url)"
    printf "$p" "$(-shell-init -D)" > $EDITOR
    chmod 755 $EDITOR || {
      echo "ERROR: could not chmod $EDITOR: $?" >&2
      return 1
    }
  fi
  if [ ! -e $SCR_VIMRC ]; then
    #-ws /scr-get-vimrc --compressed > $SCR_VIMRC
    -vimrc > $SCR_VIMRC
  fi
  $EDITOR "$@"
}

-shell-init() {
  local opts="CDvs:" opt OPTIND log_tty verbose=0 i fcns num_fcns test_mode=0 test_groups start clear_cache=0 declare_mode=0 show_test_groups pwfile
  while builtin getopts $opts opt; do
    case $opt in
      (v) verbose=1
        ;;
      (s)
        # pass start=1 to start an interactive shell, any other value is
        # assumed to be a base64 encoded command to be run (generated by
        # -ssh-serialize-cmd)
        start=$OPTARG
        ;;
      (D)
        declare_mode=1
        ;;
      (C)
        clear_cache=1
        ;;
    esac
  done
  fcns=($(compgen -A function "-") screen ssh vim)
  if [ $declare_mode = 1 ]; then
    for f in ${fcns[*]}; do
      declare -f -- $f
    done
    return
  fi
  export -f -- ${fcns[*]}
  # SCR_ENV is like node's NODE_ENV, we can use it to create a separate name
  # space for run time files and such
  export SCR_ENV=${SCR_ENV:-dev}
  export SCR_TMPDIR=/tmp/scr-$SCR_ENV
  export EDITOR=$SCR_TMPDIR/editor
  export SCR_VIMRC=$SCR_TMPDIR/vimrc
  export SCR_SCREENRC=$SCR_TMPDIR/screenrc
  pwfile="$SCR_HOME/profile/el13/passwords.gpg"
  if [ -f $pwfile ]; then
    export SCR_PASSWORD_FILE="$pwfile"
  fi
  export VIMINIT='source $SCR_VIMRC'
  # for sudo users, if they use vim and SHELL is /bin/false (or similar) then
  # rvim is used (at least on macos)
  export SHELL=$BASH
  #[ -z "$SUDO_USER" ] && rm -f $EDITOR $SCR_VIMRC
  [ ! -d $SCR_TMPDIR ] && mkdir -p $SCR_TMPDIR
  [ $clear_cache = 1 ] && -clear-cache
  eval -- "$(-bashrc)"
  if [ "$start" ]; then
    if [ "$start" = 1 ]; then
      exec bash --norc --noprofile
    else
      exec bash -c -- "-ssh-deserialize-cmd $start"
    fi
  fi
}

# sudo shortcut
# usage: arg1 is the user we want to become (default=root), remaining args are
# the command we want to run as that user
# -s
# -s nobody
# -s nobody whoami
-s() {
  local user=${1:-root} bootstr
  [ $# -gt 0 ] && shift
  [ "$STY" ] && -screen-env
  bootstr=$(-shell-boot-string $SCR_PORT "$@")
  if [ ! -e $EDITOR ]; then
    # create the editor, might need it under sudo and sudo user will not be
    # able to create it
    v --version >/dev/null
  fi
  # we pass along STY so that -ws calls can properly detect when to run
  # -screen-env
  sudo -H -u $user bash -c "STY='$STY' $bootstr"
}

-ssh-serialize-cmd() {
  local c=("$@")
  declare -p c | openssl enc -a -A
}

-ssh-deserialize-cmd() {
  # b64 is assumed to have been generated from -ssh-serialize-cmd
  local b64="$1" c
  eval -- "$(echo -n $b64 | openssl enc -d -a -A)"
  if [[ "${c[@]}" =~ \$ ]]; then
    eval -- "${c[@]}"
  else
    "${c[@]}"
  fi
}

-shell-boot-string() {
  local remote_port=$1 start
  shift
  if [ $# -gt 0 ]; then
    start=$(-ssh-serialize-cmd "$@")
  else
    start=1
  fi
  printf 'eval -- "$(curl -S -f -s --compressed http://127.0.0.1:%s/scr-get-bash-functions?start=%s)"' $remote_port $start
}

ssh() {
  local SCR_PORT_FORWARD bootstr OPTIND \
    ssh_legal_opts="1246ab:c:e:fgi:kl:m:no:p:qstvxACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy" \
    opt ssh_user_host cmd=(env ssh) start=1 N_flag=0 rc cmdline_ssh_host
  while builtin getopts $ssh_legal_opts opt; do
    #case $opt in
    #  f|N|M|V)
    #    env ssh "$@"
    #    return $?
    #    ;;
    #esac
    cmd+=("-$opt")
    [ "$OPTARG" ] && cmd+=("$OPTARG")
    # if -N is given, still allow for forwarding SCR_PORT but skip bootstr
    # (integration tests use this with a ssh control master)
    [ $opt = N ] && N_flag=1
  done
  # after this shift, the ssh user@host should be left in $1 (assuming an
  # user@host was provided on the command line, which is most of the time)
  [ $OPTIND -gt 1 ] && shift $(($OPTIND-1))
  ssh_user_host="$1"
  if [ "$ssh_user_host" ]; then
    shift
    if [ $# -eq 0 ]; then
      cmd+=(-t)
    fi
    SCR_PORT_FORWARD=$(( $RANDOM % 5000 + 56100 ))
    [ "$STY" ] && -screen-env
    cmd+=(
      -oExitOnForwardFailure=yes
      -R$SCR_PORT_FORWARD:127.0.0.1:$SCR_PORT
      "$ssh_user_host"
    )
    if [ $N_flag = 0 ]; then
      bootstr=$(-shell-boot-string $SCR_PORT_FORWARD "$@")
      cmd+=(exec bash -c "'"$bootstr"'")
      cmdline_ssh_host=${ssh_user_host##*@}
      h=$cmdline_ssh_host
      [ "$SSH_STY_LBL" ] && h=$SSH_STY_LBL
      [ "$STY" ] && printf "\033k$h\033\134"
    else
      # display for forwarded port, might have a use for this someday
      printf "SCR_PORT_FORWARD=%s\n" $SCR_PORT_FORWARD
    fi
  fi
  "${cmd[@]}"
  rc=$?
  if [ $N_flag = 0 ]; then
    [ "$STY" ] && printf "\033k${HOSTNAME}\033\134"
  fi
  return $rc
}

# copy to clipboard
-copy-to-clipboard() {
  local f="${1:-/dev/stdin}"
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f" >&2
    return 1
  fi
  -ws /scr-set-clipboard --data-binary @$f
}

-clipboard() {
  -ws /scr-get-clipboard --compressed
}

-md5() {
  local f="${1:-/dev/stdin}"
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f" >&2
    return 1
  fi
  local md5=$(openssl md5 -hex "$f")
  # md5 will look something like this:
  # MD5(somefile)= 7f851736b8f86d8ee734a5d94bedf2f7
  # remove the prefix
  md5=${md5##*= }
  # force to lowercase: OS X cannot do "md5=${md5,,}" so use tr
  echo $md5 | tr "[:upper:]" "[:lower:]"
}

#
# pick 1 line from a list. positional parameters:
#
#   intro_label: the label to display before presenting the list
#
#   pick_list: a multiline string with the choices to be given to user
#
#   use_idx: if 1, this script outputs the index number of the user's choice,
#   else we output the chosen line from pick_list
#
# example usage: 
#
#   file=$(-pick-something "Pick a file:" "$(find $logdir -type f | sort)")
#   [ -f "$file" ] && lwsa_view_file "$file"
#
# the user selected item from the original list is echoed to stdout
#
# return code: 0 user picked a valid entry from the list; 1 user did not choose
# anything; 2 user gave some other bogus choice
#
-pick-something() {
  local tty=$(tty) intro_label="$1" pick_list="$2" use_idx="$3" i l c
  local -a pick_array
  IFS=$'\n' read -d '' -a pick_array <<< "$pick_list"
  local indexes=${!pick_array[@]}
  local n=${#pick_array[@]}
  pick_list=$(
    echo "$intro_label"
    for ((i=0; i<$n; i++)); do
      l=${pick_array[$i]}
      printf "%s. %s\n" $(($i+1)) "$l"
    done
  )
  l=$(tput lines)
  if [ $((${#pick_array[@]}-2)) -gt $l ]; then
    less <<< "$pick_list" >$tty
  else
    echo "$pick_list" >$tty
  fi
  read -p "Enter choice: " c
  [ -z "$c" ] && return 1
  ! [[ "$c" =~ ^[0-9]+$ ]] && return 2
  c=$(($c-1))
  if echo $indexes | grep -q -w -- "$c"; then
    if [ "$use_idx" = 1 ]; then
      echo $c
    else
      echo "${pick_array[$c]}"
    fi
  else
    return 2
  fi
}

-download() {
  local f="$1" ext gzip=1 md5
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f"
    return 1
  fi
  ext="${f##*.}"
  md5=$(-md5 $f)
  -ws /scr-upload-file --data-binary @$f -H "x-file-name: $(basename $f)" -H "x-file-md5: $md5"
}

# upload a file from the system where Server.js is running (presumably to some
# system you are currently ssh'd to); pass a filename as arg1, else an
# interactive file picker is executed
-upload() {
  local c eot=$'\x04' upload_file="$1"
  if [ "$STY" ]; then
    -screen-env
  fi
  {
    while :; do
      # read and echo stdout from upload-file-picker script
      IFS='' read -s -d '' -n 1 c
      if [ "$c" = "$eot" ]; then
        break
      fi
      printf %s "$c"
    done
    # read info about the file about to be uploaded
    IFS=$'\r|' read status upload_file upload_file_md5 upload_file_size
    upload_file=$(basename "$upload_file")
    if [ "$status" != E_FILE_INFO ]; then
      echo "$status" >&2
      return 1
    fi
    #set -o pipefail
    # the rest of the stream from nc is the gzip'd file, use perl to print out
    # a progress indicator
    if ! gzip -d -c | perl -pe '
BEGIN {
$n=0;
$n2=0;
$s=shift @ARGV;
$freq=2**10*32;
printf STDERR "%10d/%10d",$n,$s;
}
END {
printf STDERR "\033[1G%10d",$n;
printf STDERR "\n";
}
$n+=length($_);
$n2+=length($_);
if ($n2 > $freq ) {
printf STDERR "\033[1G%10d",$n;
$n2=0;
}
' $upload_file_size > "$upload_file"; then
      echo "$FUNCNAME FAIL: $upload_file did not decompress through gzip" >&2
      return 1
    fi
    upload_file_md5a=$(-md5 "$upload_file")
    if [ $upload_file_md5 != $upload_file_md5a ]; then
      echo >&2
      echo "$FUNCNAME FAIL: md5 hash mismatch: expected $upload_file_md5, but got $upload_file_md5a" >&2
      return 1
    fi
    echo SUCCESS
    return 0
  } < <(
    {
      # user can optionally pre-pick a file to upload, if they know the full
      # path
      printf "upload_file=%s\n" "$upload_file"
      if [ -z "$upload_file" ]; then
        # interact with upload-file-picker script, up to the user pressing
        # return (\n)
        while :; do
          IFS='' read -s -d '' -n 1 c
          printf %s "$c"
          if [ "$c" = $'\n' ]; then
            break
          fi
        done
      fi
    } | nc -X connect -x 127.0.0.1:$SCR_PORT localhost 1234
  )
}

# -pw retrieves a password based on the given key, which can be supplied as arg
# 1 or passed in stdin
#
# limitation: password cannot contain a colon because that is assumed to be the
# delimiter here
-pw() {
  local pwkey="$1" delim=":" pwfile="$SCR_PASSWORD_FILE"
  if [ ! -f $pwfile ]; then
    echo "$FUNCNAME: no password file" >&2
    return 1
  fi
  [ -z "$pwkey" -a ! -t 0 ] && read pwkey
  [ -z "$pwkey" ] && return 1
  local pwline=$(gpg -qd "$pwfile" | grep -- "$pwkey$delim" | head -1)
  [ -z "$pwline" ] && return 1
  [[ "$pwline" =~ ([^$delim]+)$ ]] && echo "${BASH_REMATCH[1]}" || return 1
}

-totp() {
  local key_idx=${1:-0} otp key_id base32_key
  local key_ids=(
    "TOTP Amazon Web Services:lenio@556585969992"
    "TOTP LincWare OPS"
    "TOTP lw-401-main-st"
  )
  key_id=${key_ids[$key_idx]}
  if [ -z "$key_id" ]; then
    echo "$FUNCNAME: could not acquire base32_key using key_idx=$key_idx" >&2
    return 1
  fi
  base32_key=$(-pw "$key_id")
  otp=$(oathtool --totp -b $base32_key)
  printf "%s:%s\n" "$key_id" $otp
  printf $otp | -copy-to-clipboard
}

#
# This function greps "ps" output for a given string (case insensetively);
# similar to pgrep
#
# Usage: -psg [search_string]
#
# If stdout is the tty, the output highlights the search string in red
#
-psg() (
  local ps_cmd ps_output search_string="$*" os=$(uname) i l m matched x n=0 ATTR_RED='\x1b[1;31m' ATTR_CLEAR='\x1b[0m'
  shopt -s nocasematch
  case $os in
    OpenBSD|Darwin)
      ps_cmd="ps -jAwww"
      ;;
    Linux)
      ps_cmd="ps -fewww"
      ;;
    *)
      echo "$FUNCNAME: no support for $os" >&2
      return 1
      ;;
  esac
  ps_output="$($ps_cmd)"
  output=""
  while read l; do
    matched=0
    n=$(($n+1))
    if [ $n = 1 -o -z "$search_string" ]; then
      output+="$l"$'\n'
      continue
    elif [[ "$l" =~ $ps_cmd ]]; then
      continue
    fi
    while [[ "$l" =~ ($search_string)(.*) ]]; do
      m="${BASH_REMATCH[1]}"
      matched=1
      # x will be all text leading up to the matched search string
      x="${l%%$m*}"
      # compute the index of the search string in the line
      i=${#x}
      if [ -t 1 ]; then
        output+=$(printf "%s$ATTR_RED%s$ATTR_CLEAR" "${l:0:$i}" "$m")
      else
        output+=$(printf "%s%s" "${l:0:$i}" "$m")
      fi
      l="${l:$i+${#m}}"
    done
    [ $matched = 1 ] && output+="$l"$'\n'
  done <<< "$ps_output"

  # remove the final \n
  output=$(echo "$output")

  # display the output; if output has more lines than the terminal has rows
  # then use "less" to view it
  term_lines=$(tput lines)
  IFS=$'\n' output_array=($output)
  if [ ${#output_array[@]} -gt $term_lines ]; then
    less <<< "$output" >/dev/tty
  else
    echo "$output" >/dev/tty
  fi
)

#
# Usage: -ra [filter] [command ...]
# where filter is used as a simple search filter against all currently
# connected VMs. The user is prompted to pick the VM from a list and further
# prompted to run either ssh or sftp to that VM.
#
# If a command is given we assume it is to be run on the remote VM identified
# by the filter (and the assumption is that the filter will match on exactly 1
# VM).
#
# Programmer note: this script is designed to work on Linux, OpenBSD, and Mac
# OS X. So do not use any obscure syntax or 3rd party tools which may not exist
# in some environments, e.g., Mac OS X's bash does not support associative
# arrays.
#
# Set these environment variables as necessary (defaults in parens)
# RA_SERVER_BASE_URL (https://remoteadmin.private:3333)
# RA_SSH_USER (lincdoc)
# RA_USER ($LOGNAME)
#
#exec > >(tee >(grep ^: >$cmds) | grep -v ^:)
#trap "rm -f $stdout $cmds; echo $stdout was deleted" EXIT INT

-ra() {
  local exec ssh_params opts="he:u:j:drps" opt RA_SERVER_BASE_URL=${RA_SERVER_BASE_URL:-https://remoteadmin.private:3333} RA_SSH_USER=${RA_SSH_USER:-lincdoc} OPTIND=1 PATH="/usr/local/opt/curl/bin:$PATH"
  declare -a exec
  declare -a ssh_params
  local ssh_params_file=$HOME/.remoteadmin/ssh_options filter RA_SSH_PROXY_JUMP_HOST RA_MODE=ssh superuser=0
  local appCtx raAgentId

  usage() {
    echo "Usage: -ra [-hdr] [filter [ssh args ...]]"
    echo "       -ra [-d] -p [filter [psql args ...]]"
    echo "       -ra [-d] -s"
    echo "  -h: this usage note"
    echo "  -d: use dev remoteadmin server"
    echo "  -r: in ssh mode (the default), ssh to the remote server as root; in psql mode, connect with the owner of the ld_admin schema"
    echo "  -p: psql mode"
    echo "  -s: show current remoteadmin users"
  }

  while builtin getopts $opts opt; do
    case $opt in
      h) usage
        return
        ;;
      e) RA_SERVER_BASE_URL=$OPTARG
        echo "NOTE: using endpoint base: $RA_SERVER_BASE_URL" >/dev/tty
        ;;
      u) RA_USER_OVERRIDE=$OPTARG
        echo "NOTE: using RA_USER: $RA_USER_OVERRIDE" >/dev/tty
        ;;
      d) RA_SERVER_BASE_URL=${RA_SERVER_BASE_URL/%:3333/:3001}
        echo "NOTE: using dev RA server at: $RA_SERVER_BASE_URL" >/dev/tty
        ;;
      r) RA_SSH_USER=root
        superuser=1
        ;;
      p) RA_MODE=psql
        ;;
      s) RA_MODE=show_users
        ;;
    esac
  done
  filter=${!OPTIND}
  [ $OPTIND -gt $# ] && shift $# || shift $OPTIND
  if [ -z "$filter" ]; then
    filter="."
  fi
  if [[ "$filter" =~ ^(([^:]+):)(([_[:alnum:]]+))$ ]]; then
    raAgentId=${BASH_REMATCH[2]}
    filter=$raAgentId
    appCtx=${BASH_REMATCH[4]}
  fi
  if ! [[ $RA_SERVER_BASE_URL =~ ://([-\.[:alnum:]]+) ]]; then
    echo "could not parse RA_SSH_PROXY_JUMP_HOST from endpoint: $RA_SERVER_BASE_URL" >&2
    return 1
  fi
  RA_SSH_PROXY_JUMP_HOST=${BASH_REMATCH[1]}

  get_extra_ssh_params() {
    local hostname=$(echo $1 | tr "[:upper:]" "[:lower:]")
    local hostname2
    local line
    if [ -f $ssh_params_file ]; then
      while read -r line; do
        if [[ $line =~ ^([-\.[:alnum:]]+)=(.+) ]]; then
          hostname2=$(echo ${BASH_REMATCH[1]} | tr "[:upper:]" "[:lower:]")
          if [ ${hostname} = ${hostname2} ]; then
            printf %s "${BASH_REMATCH[2]}"
            return
          fi
        fi
      done < $ssh_params_file
    fi
  }

  if [ "$STY" ]; then
    -screen-env
  fi
  if [ "$RA_USER_OVERRIDE" ]; then
    RA_USER=$RA_USER_OVERRIDE
  fi

  if [ -z "$RA_USER" ]; then
    read -p "What is your remoteadmin username? " RA_USER </dev/tty
    [ -z "$RA_USER" ] && return 1
    read -p "Confirm: username is \"$RA_USER\" (y/n, default is y)? " yesno </dev/tty
    [ "$yesno" -a "$yesno" != y ] && return
  fi

  #local pwkey="LincWare LDAP:$RA_USER"
  #local pw=$(pw "$pwkey")
  if [ -z "$RA_USER_PASSWORD_64" ]; then
    echo "$FUNCNAME: no value for RA_USER_PASSWORD_64" >&2
    return 1
  fi
  if ! pw=$(echo "$RA_USER_PASSWORD_64" | openssl enc -d -a -A); then
    echo "$FUNCNAME: could not acquire password" >&2
    return 1
  fi
  local raw agents auth=$(printf "%s:%s" "$RA_USER" "$pw" | openssl enc -a -A)
  local ldap_auth_hdr=$(printf "Authorization: Basic %s" $auth)
  local endpoint=$RA_SERVER_BASE_URL/ra-get-agents?superuser=$superuser
  if ! [[ $RA_SERVER_BASE_URL =~ ://([-\.[:alnum:]]+) ]]; then
    echo "$FUNCNAME: could not parse hostname from endpoint: $RA_SERVER_BASE_URL" >&2
    return 1
  fi

  local agt_id=${BASH_REMATCH[1]}/127.0.0.1
  local matching=() header=() raAgentIdIdx agent=()

  get_header_idx() {
    local i
    for ((i=0;i<${#header[@]};i++)); do
      if [ ${header[$i]} = $1 ]; then
        echo $i
        return
      fi
    done
    return 1
  }

  get_data() {
    local i j data
    IFS='|' read -a data <<< "${matching[$1]}"
    for ((j=0;j<${#header[@]};j++)); do
      printf "%s=%s;" ${header[$j]} "${data[$j]}"
    done
  }

  fmt_date() {
    epoch_seconds=$1 os=$(uname -s) fmt="%m/%d %H:%M:%S"
    case $os in
      Darwin|OpenBSD)
        date -r $epoch_seconds +"$fmt"
        ;;
      Linux)
        date --date=@$epoch_seconds +"$fmt"
        ;;
    esac
  }

  if [ $RA_MODE != show_users ]; then
    if ! raw=$(curl -k -S -s -f -H "Accept: text/plain" -H "$ldap_auth_hdr" -H "X-Ra-Agent-Id: $agt_id" $endpoint); then
      echo "$FUNCNAME: failed to read $endpoint" >&2
      return 1
    fi
    IFS=$'\n' read -d '' -a agents <<< "$raw"

    IFS='|' read -a header <<< "${agents[0]}"

    if ! raAgentIdIdx=$(get_header_idx raAgentId); then
      echo "$FUNCNAME: failed to get raAgentIdIdx" >&2
      return 1
    fi

    for ((i=1;i<${#agents[@]};i++)); do
      agent=(${agents[$i]})
      raAgentId=${agent[$raAgentIdIdx]}
      if [[ $raAgentId =~ $filter ]]; then
        matching+=("${agents[$i]}")
      fi
    done

    if [ ${#matching[@]} -eq 0 ]; then
      echo "$FUNCNAME: no matches for filter: $filter" >&2
      return 1
    fi

    local n=$((${#matching[@]}-1)) choice=0
    if [ $n -ge 1 ]; then
      local choice_list=$(
        for ((i=0;i<=$n;i++)); do
          eval "$(get_data $i)"
          dt=$(fmt_date $createTimestamp)
          printf "%s (%s)\n" $raAgentId "$dt"
        done
      )
      choice=$(-pick-something "Pick:" "$choice_list" 1) || {
        echo "invalid choice"
        return 1
      }
    fi

    #get_data $choice
    eval "$(get_data $choice)"
  fi

  case $RA_MODE in
    ssh|show_users)
      # get a session cookie so we can do various web service calls
      local cookie_jar=$HOME/.remoteadmin/ra-cookies
      if [ ! -f $cookie_jar ]; then
        touch $cookie_jar
        chmod 600 $cookie_jar
      fi
      curl -k -f -s -S -b "$cookie_jar" -c "$cookie_jar" -H "X-Ra-Session-Request: 1" -H "$ldap_auth_hdr" $RA_SERVER_BASE_URL/ra-simple-login
      ;;
  esac

  case $RA_MODE in
    ssh)
      local extra_params="$(get_extra_ssh_params $raHostname)"
      if [ -n "$extra_params" ]; then
        echo "Passing extra params to ssh: $extra_params"
      fi
      if c=($(curl -k -f -s -S -b "$cookie_jar" -H "$ldap_auth_hdr" -H "X-Ra-Agent-Id: $raAgentId" $RA_SERVER_BASE_URL/ra-get-shell-ctx)); then
        SSH_STY_LBL=$raHostname ssh -t -oProxyJump=remoteadmin@$RA_SSH_PROXY_JUMP_HOST -p $raSshPort $extra_params "$@" $RA_SSH_USER@127.0.0.1 "${c[@]}" exec bash
      fi
      ;;
    psql)
      choice=0
      n=$((${#context[@]}-1))
      if [ $n -ge 1 ]; then
        if [ -z "$appCtx" ]; then
          local choice_list=$(
            for ((i=0;i<=$n;i++)); do
              printf "%s (%s/%s/%s)\n" ${context[$i]} ${ldVersion[$i]} ${database[$i]} ${username[$i]}
            done
          )
          choice=$(-pick-something "Pick:" "$choice_list" 1) || {
            echo "invalid choice" >&2
            return 1
          }
        else
          choice=-1
          for ((i=0;i<=$n;i++)); do
            if [ ${context[$i]} = $appCtx ]; then
              choice=$i
              break
            fi
          done
          if [ $choice -lt 0 ]; then
            echo "no such context: $appCtx" >&2
            echo "available contexts: ${context[*]}" >&2
            return 1
          fi
        fi
      fi
      appCtx=${context[$choice]}
      export PGDATABASE=${database[$choice]}
      export PGUSER=${username[$choice]}
      #export PGHOST=${host[$choice]}
      export PGHOST=127.0.0.1
      export PGSSLMODE=require
      export PGPORT=${port[$choice]}
      export PGOPTIONS="-c lw.raAgentId=$raAgentId/$appCtx}"
      export PGPASSWORD="$(echo ${password[$choice]} | openssl enc -d -a -A)"
      ssh -fN -L127.0.0.1:$PGPORT:127.0.0.1:$PGPORT ${host[$choice]}
      psql -v PROMPT1="$raHostname:%n@%/>" "$@"
      # do I need to stop ssh?
      ;;
    show_users)
      #local type="application/json"
      local type="text/plain"
      curl -k -f -S -H "$ldap_auth_hdr" -H "X-Ra-Agent-Id: $agt_id" -H "Accept: $type" $RA_SERVER_BASE_URL/ra-users-get-browser-windows
      ;;
  esac
}
