# vim filetype=bash

l() {
  ls -laF "$@"
}
export -f l

-vars() {
  set | grep ^SCR
}

-clear-cache() {
  if [[ "$SCR_TMPDIR" =~ ^/tmp/ ]]; then
    rm -rf $SCR_TMPDIR/*
    echo "cleaned out $SCR_TMPDIR"
  fi
}

#
# call within gnu screen to update important environment variables; in
# particular, this must be called prior to any call to -ws or -ssh
-screen-env() {
  local opts="uS:" opt OPTIND update=0 v SCR_UPDATEABLE="SCR_PORT SSH_AUTH_SOCK" file_prefix=scr-sty-fifo
  # keep STY local so we don't pollute parent shell when reconnecting to a gnu
  # screen session
  local STY=$STY
  while builtin getopts $opts opt; do
    case $opt in
      (u) update=1
        ;;
      (S) STY=$OPTARG
        ;;
    esac
  done
  if [ -z "$STY" ]; then
    echo "$FUNCNAME: no value for STY" >&2
    return 1
  fi
  local session_id=${STY##*.}
  local SCR_STY_FIFO=$SCR_TMPDIR/$file_prefix-$session_id
  local old_fifo old_fifo_id
  for old_fifo in $(ls $SCR_TMPDIR/$file_prefix-* 2>/dev/null); do
    if [[ $old_fifo =~ $file_prefix-(.*) ]]; then
      old_fifo_id=${BASH_REMATCH[1]}
      if ! screen -ls | grep -q $old_fifo_id; then
        rm -f $old_fifo
        if [ /dev/tty ]; then
          echo "removed old fifo: $old_fifo" >/dev/tty
        fi
      fi
    fi
  done
  if [ $update = 1 ]; then
    # update critical environment variables
    local buf=$(
      for v in $SCR_UPDATEABLE; do
        if [ "${!v}" ]; then
          printf "%s='%s';" $v ${!v}
        fi
      done
    )
    # set buf to ":" if it is unset: want to avoid an empty register
    if ! env screen -S $session_id -X register . "${buf:-:}"; then
      echo "$FUNCNAME: failed to update environment for $session_id: $buf" >&2
      return 1
    fi
    echo "$FUNCNAME: successful update on $session_id: $buf"
    return
  fi
  if [ ! -e $SCR_STY_FIFO ]; then
    mkfifo -m 0600 $SCR_STY_FIFO
  fi
  # paste the contents of register "p" into the named pipe, then source it's
  # contents into the current shell. UPDATE: not using "p", just the direct
  # paste buffer because there is a bug that the first paste of a register to
  # the paste buffer from an initially detached screen will not work
  if env screen -S $session_id -X writebuf $SCR_STY_FIFO; then
    # note: cannot do "source $SCR_STY_FIFO" here, at least not with bash 3.2
    # on Mac
    eval "$(<$SCR_STY_FIFO)"
  else
    echo "$FUNCNAME: failed to load data from paste buffer" >&2
    return 1
  fi
}

-debug-ts() {
  echo "${FUNCNAME[*]}:$@:$(date +%s)" >> $SCR_TMPDIR/a
}

-random-string() {
  local length=${1:-16} r="" c
  while [ ${#r} -lt $length ]; do
    read -n 1 c
    r+=$c
  done < <(LC_ALL=C tr -dc A-Za-z0-9 </dev/urandom)
  echo $r
}

-pick-sty() {
  local stys pick_sty pick_sty_line session_id curr_sty=${STY:-no_such_sty_exists}
  # make a pick list of available session ids
  stys=$(
    while read l; do
      if [[ "$l" =~ ^[[:blank:]]*([0-9]+\.[^[:blank:]]+)[[:blank:]]+([[:print:]]+) ]]; then
        pick_sty=${BASH_REMATCH[1]}
        pick_sty_status=${BASH_REMATCH[2]}
        echo "$pick_sty $pick_sty_status"
      fi
    done < <(env screen -ls | grep -v $curr_sty)
  )
  if [ -z "$stys" ]; then
    echo "No screen sessions detected." >/dev/tty
    return 0
  fi
  if ! pick_sty_line=$(-pick-something "Resume which session?" "$stys"); then
    return $?
  fi
  if [[ $pick_sty_line =~ ^([0-9]+\.([-[:alnum:]]+)) ]]; then
    pick_sty=${BASH_REMATCH[1]}
    session_id=${BASH_REMATCH[2]}
    echo $session_id
  else
    echo "$FUNCNAME: no match for pick_sty_line: $pick_sty_line" >&2
    return 1
  fi
}

# wrapper around gnu screen. Call with "-test" to run the test suite
screen() {
  local i i2 next_arg rcfile session_id_prefix="scr-" session_id opt run_tests=0 cmd=() env=() esc=^Aa update=0 command=0 skip=0
  for ((i=1;i<=$#;i++)); do
    i2=$((i+1))
    next_arg="${!i2}"
    opt="${!i}"
    skip=0
    case $opt in
      (--generate-session-id)
        printf "%s%s" $session_id_prefix $(-random-string 4)
        return
        ;;
      (-ls|-list|-wipe|-Q|-D|-R)
        env screen "$@"
        return $?
        ;;
      (-X)
        if [ $update = 1 ]; then
          if ! -screen-env -S $session_id -u; then
            return $?
          fi
        fi
        env screen "$@"
        return $?
        ;;
      (-r)
        if [[ "$next_arg" =~ ^[[:alnum:]] ]]; then
          session_id=$next_arg
        else
          if ! session_id=$(-pick-sty); then
            return $?
          fi
        fi
        if [[ $session_id =~ ^$session_id_prefix ]]; then
          if ! -screen-env -S $session_id -u; then
            return $?
          fi
        fi
        set -- "${@:1:i-1}" -r $session_id "${@:i+1}"
        cmd+=("$@")
        env screen "${cmd[@]}"
        return $?
        ;;
      (-u)
        set -- "${@:1:i-1}" "${@:i+1}"
        let i-=1
        skip=1
        update=1
        ;;
      (-S)
        session_id=$next_arg
        ;;
      (-c)
        rcfile=$next_arg
        ;;
    esac
    [ $skip = 0 ] && cmd+=("$opt")
  done
  #if ! [[ "${cmd[@]}" =~ -S\ +[[:alnum:]] ]]; then
  if ! [ "$session_id" ]; then
    session_id=$($FUNCNAME --generate-session-id)
    cmd+=(-S $session_id)
  fi
  if [ -z "$rcfile" -a "$session_id" ]; then
    rcfile=$SCR_TMPDIR/screenrc
    env+=(
      SCR_STY_LAST_UPDATE="$(date)"
    )
    cmd+=(-c $rcfile)
    cat << EOF >$rcfile
register . ":"
#screen bash -c "bootfunc 1 < <(echo $SCR_TERM_AUTH_TOKEN; tty)"
#bind c screen bash -c "bootfunc 0 < <(echo $SCR_TERM_AUTH_TOKEN; tty)"
$(
  if [ $run_tests = 1 ]; then
    printf "screen bash -c -- -test\n"
  else
    printf "screen bash\n"
  fi
)
multiuser off
# bind "%" to take a screenshot, and open a new window to edit it
bind % exec bash -c 'f=\$(mktemp) t=\$RANDOM; env screen -X hardcopy \$f; env screen -t \$t sh -c "$SCR_EDITOR \$f; rm \$f"; env screen -X select \$t'
bind \040 windowlist -b
vbell on
vbell_msg DING
defmonitor on
msgwait 1
#hardstatus ignore
shelltitle "$ |:"
caption always "%{= kw}%-w%{= BW}%n%t%{-}%+w %-= @%H %{= Y}%l%{-} %m/%d %0c$esh_info"
bind P eval "password none" "detach"
EOF
  fi
  if [ "$SSH_TTY" ]; then
    esc=^Ee
  fi
  # strip off "screen." prefix from $TERM to avoid "$TERM too long" issue
  cmd+=(-T ${TERM#screen.} -ln -e$esc "$@")
  env "${env[@]}" screen "${cmd[@]}"
}
export -f screen

-ws() {
  [ "$STY" ] && -screen-env
  local base_url=http://127.0.0.1:$SCR_PORT endpoint=$1 url rc
  shift
  printf -v url "%s%s" $base_url $endpoint
  set -- "$@" "$url"
  curl -f -S -s "$@"
  rc=$?
  if [ $rc -gt 0 ]; then
    echo "curl failed with arguments: $@" >&2
    echo "stack trace: ${FUNCNAME[*]}" >&2
  fi
  return $rc
}

-ws-hello-world() {
  -ws /scr-hello-world -f -S "$@"
}

# runs a bash command in gnu screen, waiting for the command to finish
-screen-pipe() {
  local stdin stdout stderr rcfifo fifo eof_stdout=0 eof_stderr=0 opts="uS:c:" opt OPTIND cmd=()
  printf -v stdin "%s/sty-stdin-fifo" $SCR_TMPDIR
  printf -v stdout "%s/sty-stdout-fifo" $SCR_TMPDIR
  printf -v stderr "%s/sty-stderr-fifo" $SCR_TMPDIR
  printf -v rcfifo "%s/sty-rc-fifo" $SCR_TMPDIR
  while builtin getopts $opts opt; do
    case $opt in
      (u)
        cmd+=(-u)
        ;;
      (S)
        cmd+=(-S $OPTARG)
        ;;
    esac
  done
  # remaining args are the command to be run in the new screen window we are
  # about to create
  shift $(($OPTIND-1))
  cmd+=(-X screen bash -c -- "exec 0<$stdin 1>$stdout 2>$stderr 3>$rcfifo bash")
  for fifo in $stdin $stdout $stderr $rcfifo; do
    if [ ! -e $fifo ]; then
      mkfifo $fifo
    fi
  done
  {
    c=("$@")
    declare -p c
    echo '"${c[@]}"'
    echo 'rc=$?'
    echo 'echo $rc >&3'
    echo 'exit'
  } >$stdin &
  while :; do
    read -d '' <$stdout || eof_stdout=1
    [ "$REPLY" ] && echo "$REPLY"
    [ $eof_stdout = 1 ] && break
  done &
  stdout_pid=$!
  while :; do
    read -d '' <$stderr || eof_stderr=1
    [ "$REPLY" ] && echo "$REPLY" >&2
    [ $eof_stderr = 1 ] && break
  done &
  screen "${cmd[@]}"
  read -d '' rc <$rcfifo
  return $rc
}

v() {
  if [ -z "$EDITOR" ]; then
    echo "$FUNCNAME: EDITOR is not set" >&2
    return 1
  fi
  local d=$(dirname $EDITOR)
  [ ! -d $d ] && mkdir -p $d
  if [ ! -e $EDITOR ]; then
    local p='#!/usr/bin/env bash
[ "$1" = "--version" ] && exec vim "$@"
%s
exec vim "$@"
'
    #local url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
    #eval "$(curl -S -f -s --compressed $url)"
    printf "$p" "$(-shell-init)" > $EDITOR
    chmod 755 $EDITOR || {
      echo "ERROR: could not chmod $EDITOR: $?" >&2
      return 1
    }
  fi
  if [ ! -e $SCR_VIMRC ]; then
    -ws /scr-get-vimrc --compressed > $SCR_VIMRC
  fi
  $EDITOR -u $SCR_VIMRC "$@"
}
export -f v

-shell-init() {
  local opts="vts:" opt OPTIND log_tty verbose=0 i fcns num_fcns test_mode=0 start
  while builtin getopts $opts opt; do
    case $opt in
      (v) verbose=1
        ;;
      (t) test_mode=1
        url="http://127.0.0.1:$SCR_PORT/scr-get-test-framework"
        eval "$(curl -S -f -s --compressed $url)"
        SCR_ENV=test
        ;;
      (s)
        # pass start=1 to start an interactive shell, any other value is
        # assumed to be a base64 encoded command to be run (generated by
        # -ssh-serialize-cmd)
        start=$OPTARG
        ;;
    esac
  done
  export -f -- $(compgen -A function "-")
  # SCR_ENV is like node's NODE_ENV, we can use it to create a separate name
  # space for run time files and such
  export SCR_ENV=${SCR_ENV:-dev}
  export SCR_TMPDIR=/tmp/scr-$SCR_ENV
  export EDITOR=$SCR_TMPDIR/scr-editor
  export SCR_VIMRC=$SCR_TMPDIR/scr-vimrc
  #[ -z "$SUDO_USER" ] && rm -f $EDITOR $SCR_VIMRC
  [ ! -d $SCR_TMPDIR ] && mkdir -p $SCR_TMPDIR
  if [ $test_mode = 1 ]; then
    exec bash -c -- -test
  elif [ "$start" ]; then
    if [ "$start" = 1 ]; then
      exec bash
    else
      exec bash -c -- "-ssh-deserialize-cmd $start"
    fi
  fi
}

-s() {
  local user=$1 tmpfile=$(mktemp)
  -shell-init > $tmpfile
  chmod 644 $tmpfile
  sudo -u $user bash $tmpfile
  rm -f $tmpfile
}

-ssh-serialize-cmd() {
  local c=("$@")
  declare -p c | openssl enc -a -A
}

-ssh-deserialize-cmd() {
  # b64 is assumed to have been generated from -ssh-serialize-cmd
  local b64="$1" c
  eval "$(echo -n $b64 | openssl enc -d -a -A)"
  "${c[@]}"
}

ssh() {
  local remote_port bootstr OPTIND \
    ssh_legal_opts="1246ab:c:e:fgi:kl:m:no:p:qstvxACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy" \
    opt ssh_user_host cmd=(env ssh) start=1
  while builtin getopts $ssh_legal_opts opt; do
    #case $opt in
    #  f|N|M|V)
    #    env ssh "$@"
    #    return $?
    #    ;;
    #esac
    cmd+=("-$opt")
    [ "$OPTARG" ] && cmd+=("$OPTARG")
  done
  # after this shift, the ssh user@host should be left in $1 (assuming an
  # user@host was provided on the command line, which is most of the time)
  [ $OPTIND -gt 1 ] && shift $(($OPTIND-1))
  ssh_user_host="$1"
  if [ "$ssh_user_host" ]; then
    shift
    if [ $# -gt 0 ]; then
      #start=$(c=("$@"); declare -p c | openssl enc -a -A)
      start=$(-ssh-serialize-cmd "$@")
    else
      start=1
      cmd+=(-t)
    fi
    remote_port=$(( $RANDOM % 5000 + 56100 ))
    printf -v bootstr "'eval \"\$(curl -S -f -s --compressed http://127.0.0.1:%s/scr-get-bash-functions?start=%s)\"'" $remote_port $start
    [ "$STY" ] && -screen-env
    cmd+=(
      -oExitOnForwardFailure=yes
      -R$remote_port:127.0.0.1:$SCR_PORT
      "$ssh_user_host"
      exec bash -c $bootstr
    )
  fi
  "${cmd[@]}"
}
export -f ssh

# copy to clipboard
-copy-to-clipboard() {
  local f="${1:-/dev/stdin}"
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f" >&2
    return 1
  fi
  -ws /scr-copy-to-clipboard --data-binary @$f
}

-clipboard() {
  -ws /scr-get-clipboard --compressed
}

-md5() {
  local f="${1:-/dev/stdin}"
  if [ ! -e "$f" ]; then
    echo "$FUNCNAME: no such file, or file is not readable: $f" >&2
    return 1
  fi
  local md5=$(openssl md5 -hex "$f")
  # md5 will look something like this:
  # MD5(somefile)= 7f851736b8f86d8ee734a5d94bedf2f7
  # remove the prefix
  md5=${md5##*= }
  # force to lowercase: OS X cannot do "md5=${md5,,}" so use tr
  echo $md5 | tr "[:upper:]" "[:lower:]"
}

#
# pick 1 line from a list. positional parameters:
#
#   intro_label: the label to display before presenting the list
#
#   pick_list: a multiline string with the choices to be given to user
#
#   use_idx: if 1, this script outputs the index number of the user's choice,
#   else we output the chosen line from pick_list
#
# example usage: 
#
#   file=$(-pick-something "Pick a file:" "$(find $logdir -type f | sort)")
#   [ -f "$file" ] && lwsa_view_file "$file"
#
# the user selected item from the original list is echoed to stdout
#
# return code: 0 user picked a valid entry from the list; 1 user did not choose
# anything; 2 user gave some other bogus choice
#
-pick-something() {
  local tty=$(tty) intro_label="$1" pick_list="$2" use_idx="$3" i l c
  local -a pick_array
  IFS=$'\n' read -d '' -a pick_array <<< "$pick_list"
  local indexes=${!pick_array[@]}
  local n=${#pick_array[@]}
  pick_list=$(
    echo "$intro_label"
    for ((i=0; i<$n; i++)); do
      l=${pick_array[$i]}
      printf "%s. %s\n" $(($i+1)) "$l"
    done
  )
  l=$(tput lines)
  if [ $((${#pick_array[@]}-2)) -gt $l ]; then
    less <<< "$pick_list" >$tty
  else
    echo "$pick_list" >$tty
  fi
  read -p "Enter choice: " c
  [ -z "$c" ] && return 1
  ! [[ "$c" =~ ^[0-9]+$ ]] && return 2
  c=$(($c-1))
  if echo $indexes | grep -q -w -- "$c"; then
    if [ "$use_idx" = 1 ]; then
      echo $c
    else
      echo "${pick_array[$c]}"
    fi
  else
    return 2
  fi
}
