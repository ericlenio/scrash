#! /usr/bin/env bash

-init() {
  set -e
  TEST_STATUS=SUCCESS
  TEST_SOURCE_FILE=''
  export SCR_PORT=$((50000+$RANDOM % 10000))
  export SCR_ENV=test
  trap -- -on-error ERR
  trap -- -on-exit EXIT

  for opt in "$@"; do
    case "$opt" in
      (-h)
        no_server=1
        ;;
    esac
  done

  if [ ${no_server:-0} = 0 ]; then
    fifo=/tmp/scr-test-fifo
    if [ ! -e $fifo ]; then
      mkfifo $fifo
    fi
    npm start -- -p $SCR_PORT -n $fifo &
    # once this read is done, we know the server is up and listening
    read port<$fifo
    rm $fifo
  fi

  url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
  eval "$(curl -S -f -s --compressed $url)"
  -shell-init
  # TEST_ERROR_FILE is a semaphore to stop -on-error from running more than
  # once; necessary due to "set -E"
  TEST_ERROR_FILE=$SCR_TMPDIR/err
  rm -f $TEST_ERROR_FILE
}

-on-error() {
  local i
  if [ -e $TEST_ERROR_FILE ]; then
    return
  fi
  touch $TEST_ERROR_FILE
  TEST_STATUS=FAIL
  echo "ERROR with command: $BASH_COMMAND" >&2
  echo "BASH_ARGV[${#BASH_ARGV[*]}]: ${BASH_ARGV[*]}" >&2
  echo "in file: $TEST_SOURCE_FILE" >&2
  for ((i=0;i<${#BASH_LINENO[*]};i++)); do
    echo "  at line: ${FUNCNAME[$i]} ${BASH_LINENO[$i]}" >&2
  done
}

-on-exit() {
  local rc=$?
  set +e
  if [ $rc -gt 0 ]; then
    -on-error
  fi
  -cleanup
  echo $TEST_STATUS
}

-cleanup() {
  curl http://127.0.0.1:$SCR_PORT/scr-shutdown
}

-ssh-not-strict() {
   # disable "Warning: Permanently added ..." by using error log level
   ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=error "$@"
}

-ssh-localhost() {
   -ssh-not-strict localhost "$@"
}

-run-tests() {
  for TEST_SOURCE_FILE in $(find $(dirname $0) -name *.test | sort); do
    echo "START $TEST_SOURCE_FILE"
    source $TEST_SOURCE_FILE
    echo "END $TEST_SOURCE_FILE"
  done
}

-init "$@"
-run-tests
