#! /usr/bin/env bash
# this script launches the test cases

-usage() {
  echo "usage:
this help:
  npm test -- -h
run all test cases:
  npm test
run all test cases using a custom profile:
  npm test -- -P my_profile
run test cases for those test case files that match the word \"basic\":
  npm test -- -g basic
same as above, but also include test case file(s) matching on \"vim\":
  npm test -- -g \"basic vim\"
"
}

-init() {
  local opts="hg:P:" opt OPTIND
  set -eE
  # force "set -e" to be inherited with "export SHELLOPTS"
  export SHELLOPTS
  while builtin getopts $opts opt; do
    case "$opt" in
      (h)
        -usage
        exit
        ;;
      (g)
        TEST_GROUPS="$OPTARG"
        ;;
      (P)
        SCR_PROFILE="$OPTARG"
        ;;
    esac
  done

  TEST_SOURCE_FILE=''
  TEST_GROUPS=${TEST_GROUPS:=*}
  export SCR_PORT=$((50000+$RANDOM % 10000))
  export SCR_ENV=test
  export SCR_PROFILE=${SCR_PROFILE:-$USER}
  export SCR_HOME="$npm_config_local_prefix"
  export SCR_TEST_OTP=123456
  export SCR_SSH_USER=$USER
  trap -- -on-error ERR
  trap -- -on-exit EXIT
  shopt -s gnu_errfmt

  fifo=/tmp/scr-test-fifo
  if [ ! -e $fifo ]; then
    mkfifo $fifo
  fi
  npm start -- -p $SCR_PORT -n $fifo &
  # once this read is done, we know the server is up and listening
  read port<$fifo
  rm $fifo
  if ! [[ "$port" =~ ^[0-9]+$ ]]; then
    exit 1
  fi

  url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
  eval -- "$(curl -S -f -s --compressed $url)"
  -shell-init -C
  # TEST_ERROR_FILE is a semaphore to stop -on-error from running more than
  # once; necessary due to "set -E"
  TEST_ERROR_FILE="$SCR_TMPDIR/err"
  # TEST_CLEANUP_FILE will be sourced in the cleanup stage, append commands
  # here as needed to do any housekeeping (e.g. kill any started gnu screen
  # sessions)
  TEST_CLEANUP_FILE="$SCR_TMPDIR/cleanup"
  rm -f "$TEST_ERROR_FILE" "$TEST_CLEANUP_FILE"
  export SCR_SSH_USER_KNOWN_HOSTS=$SCR_TMPDIR/ssh-$SCR_SSH_USER-known-hosts
}

-on-error() {
  #echo "INSIDE $FUNCNAME[$BASH_SUBSHELL]: $BASH_COMMAND" >&2
  local i
  #if [ -e $TEST_ERROR_FILE ]; then
    #return
  #fi
  trap - ERR
  if [ "$TEST_ERROR_FILE" ]; then
    touch "$TEST_ERROR_FILE"
  fi
  echo "ERROR with command (subshell level: $BASH_SUBSHELL): $BASH_COMMAND" >&2
  if [ $BASH_SUBSHELL -gt 0 ]; then
    #echo "BASH_ARGV[${#BASH_ARGV[*]}]: ${BASH_ARGV[*]}" >&2
    #echo "in file: $TEST_SOURCE_FILE" >&2
    for ((i=0;i<${#BASH_LINENO[*]};i++)); do
      echo "  at line: ${FUNCNAME[$i]} ${BASH_LINENO[$i]}" >&2
    done
  else
    echo "caller detail (line number is first):" >&2
    #read fail_script_line_number fail_script < <(caller)
    #echo "FAIL at line $fail_script_line_number in file: $fail_script" >&2
    i=0
    while caller $i >&2; do
      let i+=1
    done
  fi
}

-on-exit() {
  #echo "INSIDE $FUNCNAME" >&2
  local rc=$?
  set +eE
  #if [ $rc -gt 0 ]; then
    #-on-error
  #fi
  -cleanup
  if [ $rc -gt 0 -o -e "$TEST_ERROR_FILE" ]; then
    echo "FAIL"
  else
    echo "SUCCESS"
  fi
}

-cleanup() {
  if [ -e "$TEST_CLEANUP_FILE" ]; then
    . "$TEST_CLEANUP_FILE"
  fi
  curl -s http://127.0.0.1:$SCR_PORT/scr-shutdown
}

-ssh-not-strict() {
  # confirm ssh-agent is running so we can automatically do some ssh stuff
  if [ -z "$SSH_AUTH_SOCK" ]; then
    echo "$FUNCNAME: expected SSH_AUTH_SOCK to be set for password-less ssh" >&2
    return 1
  fi
  # disable "Warning: Permanently added ..." by using error log level
  ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=error "$@"
}

-ssh-localhost() {
  -ssh-not-strict localhost "$@"
}

-run-tests() {
  for TEST_SOURCE_FILE in $(find $(dirname $0) -name *.test | sort); do
    for test_group in $TEST_GROUPS; do
      if [[ $TEST_SOURCE_FILE =~ $test_group ]]; then
        echo "START $TEST_SOURCE_FILE"
        source $TEST_SOURCE_FILE
        echo "END $TEST_SOURCE_FILE"
      fi
    done
  done
}

-screen-session() {
  local opts=r opt OPTIND
  local session_id=$(screen --generate-session-id)
  local cmd=(screen -S $session_id -d -m)
  while builtin getopts $opts opt; do
    case "$opt" in
      (r)
        # start gnu screen "remotely" over localhost ssh
        cmd=(-ssh-localhost "${cmd[@]}")
        ;;
    esac
  done
  "${cmd[@]}"
  printf "screen -S %s -X quit" $session_id >> "$TEST_CLEANUP_FILE"
  echo $session_id
}

-init "$@"
-run-tests
