#! /usr/bin/env bash

-usage() {
  echo "usage:
this help:
  npm test -- -h
run all test cases:
  npm test
run test cases for those test case files that match the word \"basic\":
  npm test -- -g basic
same as above, but also include test case file(s) matching on \"vim\":
  npm test -- -g \"basic vim\"
"
}

-init() {
  local opts="hg:" opt OPTIND
  set -e
  TEST_STATUS=SUCCESS
  TEST_SOURCE_FILE=''
  TEST_GROUPS='*'
  export SCR_PORT=$((50000+$RANDOM % 10000))
  export SCR_ENV=test

  while builtin getopts $opts opt; do
    case "$opt" in
      (h)
        -usage
        exit
        ;;
      (g)
        TEST_GROUPS="$OPTARG"
        ;;
    esac
  done

  trap -- -on-error ERR
  trap -- -on-exit EXIT

  fifo=/tmp/scr-test-fifo
  if [ ! -e $fifo ]; then
    mkfifo $fifo
  fi
  npm start -- -p $SCR_PORT -n $fifo &
  # once this read is done, we know the server is up and listening
  read port<$fifo
  rm $fifo

  url="http://127.0.0.1:$SCR_PORT/scr-get-bash-functions"
  eval -- "$(curl -S -f -s --compressed $url)"
  -shell-init
  # TEST_ERROR_FILE is a semaphore to stop -on-error from running more than
  # once; necessary due to "set -E"
  TEST_ERROR_FILE=$SCR_TMPDIR/err
  rm -f $TEST_ERROR_FILE
}

-on-error() {
  local i
  if [ -e $TEST_ERROR_FILE ]; then
    return
  fi
  touch $TEST_ERROR_FILE
  TEST_STATUS=FAIL
  echo "ERROR with command: $BASH_COMMAND" >&2
  echo "BASH_ARGV[${#BASH_ARGV[*]}]: ${BASH_ARGV[*]}" >&2
  echo "in file: $TEST_SOURCE_FILE" >&2
  for ((i=0;i<${#BASH_LINENO[*]};i++)); do
    echo "  at line: ${FUNCNAME[$i]} ${BASH_LINENO[$i]}" >&2
  done
}

-on-exit() {
  local rc=$?
  set +e
  if [ $rc -gt 0 ]; then
    -on-error
  fi
  -cleanup
  echo $TEST_STATUS
}

-cleanup() {
  curl http://127.0.0.1:$SCR_PORT/scr-shutdown
}

-ssh-not-strict() {
   # disable "Warning: Permanently added ..." by using error log level
   ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=error "$@"
}

-ssh-localhost() {
   -ssh-not-strict localhost "$@"
}

-run-tests() {
  for TEST_SOURCE_FILE in $(find $(dirname $0) -name *.test | sort); do
    for test_group in $TEST_GROUPS; do
      if [[ $TEST_SOURCE_FILE =~ $test_group ]]; then
        echo "START $TEST_SOURCE_FILE"
        source $TEST_SOURCE_FILE
        echo "END $TEST_SOURCE_FILE"
      fi
    done
  done
}

-init "$@"
-run-tests
