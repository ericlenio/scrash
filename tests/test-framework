# vim filetype=bash

-assert() {
  local status=FAIL assertion opts="br:" opt OPTIND base64=0 raw_mode_named_pipe
  while builtin getopts "$opts" opt; do
    case $opt in
      (b)
        # assertion is base 64 encoded
        base64=1
        ;;
      (r)
        raw_mode_named_pipe=$OPTARG
        ;;
    esac
  done
  [ $OPTIND -gt 1 ] && shift $(($OPTIND-1))
  assertion="$1"
  if [ $base64 = 1 ]; then
    assertion="$(echo $assertion | openssl enc -d -a -A)"
  fi
  if eval -- "$assertion"; then
    status="PASS"
  fi
  if [ -z "$raw_mode_named_pipe" ]; then
    -assert-result $status "$assertion"
    #printf "%s. %s: %s\n" $num_assertions $status "$assertion"
  else
    printf "%s\t%s\n" $status "$assertion" >$raw_mode_named_pipe
  fi
  if [ $status = FAIL ]; then
    return 1
  fi
}

-assert-result() {
  local status=$1 assertion="$2"
  let assertion_counter+=1
  printf "%s. %s: %s\n" $assertion_counter $status "$assertion"
  if [ $status = PASS ]; then
    let assertion_successes+=1
  else
    let assertion_fails+=1
    return 1
  fi
}

-assert-sty() {
  local assertion="$1" STY="$2" eof
  assertion64=$(echo "$assertion" | openssl enc -a -A)
  screen -X screen bash -c -- "-assert -b $assertion64"
  eof=0
  while :; do
    unset REPLY
    if ! read; then
      eof=1
    fi
    if [ "$REPLY" ]; then
      echo "$REPLY"
    fi
    if [ $eof = 1 ]; then
      break
    fi
  done
}

-test-sty-launch() {
  local STY_ID="$1" i n eof_stdout=0 eof_stderr=0 result
  set -e

  screen -S $STY_ID -X screen bash -c -- -test-sty
  while :; do
    unset REPLY
    if ! read -d '' <$SCR_TEST_STY_STDOUT; then
      eof_stdout=1
    fi
    if [ "$REPLY" ]; then
      echo "$REPLY"
    fi
    if [ $eof_stdout = 1 ]; then
      break
    fi
  done &

  # noting that stderr is properly closed, but stdout still listening for output; "echo -n '' > stdout" seems to close it
  while :; do
    unset REPLY
    if ! read -d '' <$SCR_TEST_STY_STDERR; then
      eof_stderr=1
    fi
    if [ "$REPLY" ]; then
      echo "$REPLY" >&2
    fi
    if [ $eof_stderr = 1 ]; then
      break
    fi
  done &

  -test-sty-assertions
  n=${#SCR_TEST_STY_ASSERTIONS[@]}
  for ((i=0;i<$n;i++)); do
    IFS=$'\t' read -t 1 -ra result <$SCR_TEST_STY_TEST_RESULT || true
#read result <$SCR_TEST_STY_TEST_RESULT || true
    if ! -assert-result "${result[@]}"; then
echo "ans:$?:${result[@]}" >&2
break
fi
  done

  wait
}

-test-sty-assertions() {
  # grrrrrrr bash arrays are not exportable so dedicating an exportable
  # function to do it
  SCR_TEST_STY_ASSERTIONS=(
    '[ ${#STY} -gt 0 ]'
    '! [ -e $SCR_STY_FIFO ]'
    '-screen-env'
    '[ -e $SCR_STY_FIFO ]'
    '-ws-hello-world >/dev/null'

    # start a gnu screen in ssh session
    'session_id=$(screen --generate-session-id)'
    '-ssh-localhost screen -S $session_id -d -m'
    'screen -ls | grep -q $session_id'
    'screen -S $session_id -X quit'

    # disconnect/reconnect screen over ssh
    'session_id=$(screen --generate-session-id)'
    '-ssh-localhost screen -S $session_id -d -m'
    't1=$SCR_TMPDIR/t1'
# 'set > $t1' #WORKS
#'-ssh-localhost screen -S $session_id -X screen bash -c -- "touch $t1 /tmp/t2"' #WORKS
    '-ssh-localhost screen --generate-session-id'
    '-ssh-localhost screen -u -S $session_id -X screen bash -c -- "-ws-hello-world -v -o $t1"'
    '[ -e $t1 ]'
    'grep -q $session_id $t1'
    #'rm $t1'
    'sleep 0.5'
    'screen -ls | grep -q $session_id'
  )
}

# this runs the test cases for gnu screen
-test-sty() {
  local assertion
  set -e
  exec 1>$SCR_TEST_STY_STDOUT 2>$SCR_TEST_STY_STDERR
  -test-sty-assertions
  for assertion in "${SCR_TEST_STY_ASSERTIONS[@]}"; do
    -assert -r $SCR_TEST_STY_TEST_RESULT -- "$assertion"
#echo "assertion=$assertion" >$SCR_TEST_STY_TEST_RESULT
  done
  #osascript -e 'tell application (path to frontmost application as text) to display dialog "Hello from osxdaily.com" buttons {"OK"} with icon stop'
}

-ssh-localhost() {
   # disable "Warning: Permanently added ..." by using error log level
   ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=error localhost "$@"
}

-test() (
  local num_assertions=${1:-1} len=8 env_file=$SCR_TMPDIR/esh-test-log opts="r" opt OPTIND
  assertion_counter=0
  assertion_successes=0
  assertion_fails=0
  declare -x SCR_TEST_ASSERTIONS=(
    # basic
    '[[ $SCR_PORT =~ ^[0-9]+$ ]]'
    'v=$(-random-string $len)'
    '[ $len = ${#v} ]'
    '-ws-hello-world >/dev/null'
    '-ws-hello-world | grep -q "hello world"'
    'session_id=$(screen --generate-session-id)'
    '[ ${#session_id} -gt 0 ]'
    '[[ $session_id =~ ^[-[:alnum:]]+$ ]]'
    '[ -d $SCR_TMPDIR ]'
    '[ $SCR_ENV = test ]'

    # vim
    '[ ${#EDITOR} -gt 0 ]'
    'v --version >/dev/null'
    '[ -e $EDITOR ]'
    'rm $EDITOR'
    'v --version >/dev/null'
    '[ -e $EDITOR ]'

    # start/stop gnu screen
    'screen -S $session_id -d -m'
    'screen -ls | grep -q $session_id'
    'screen -S $session_id -X quit'
    '! screen -ls | grep -q $session_id'

    'SCR_TEST_STY=$(screen --generate-session-id)'
    'screen -S $SCR_TEST_STY -d -m'
    'screen -ls | grep -q $SCR_TEST_STY'
    '-test-sty-launch $SCR_TEST_STY'
    'screen -S $SCR_TEST_STY -X quit'
    '! screen -ls | grep -q $SCR_TEST_STY'

    # ssh
    'h=$(-ssh-localhost hostname)'
    '[ $h = $(hostname) ]'
    # remote SCR_PORT from ssh session should always be different from parent shell
    'remote_port=$(eval $(-ssh-localhost declare -p SCR_PORT); echo $SCR_PORT)'
    '[ $remote_port != $SCR_PORT ]'
    '[[ $remote_port =~ ^[0-9]+$ ]]'

    # md5
    's="hello world"'
    't=$(mktemp) && echo "$s" > $t'
    '[ $(-md5 $t) = 6f5902ac237024bdd0c176cb93063dc4 ]'
    '[ $(echo "$s" | -md5) = 6f5902ac237024bdd0c176cb93063dc4 ]'
    '! -md5 /no-such-file'
    'rm $t'

    # clipboard
    'r=$(-random-string $len)'
    '[ $len = ${#r} ]'
    'echo -n $r | -copy-to-clipboard'
    'r2=$(-clipboard)'
    '[ $r = $r2 ]'
    '-copy-to-clipboard /etc/passwd'
    '[ $(-clipboard | -md5) = $(-md5 /etc/passwd) ]'

    # clipboard over ssh
    't=$(mktemp) && uname -a > $t'
    '-ssh-localhost -copy-to-clipboard $t'
    '[ $(-md5 $t) = $(-clipboard | -md5) ]'
    'rm $t'
  )

  -clear-cache

  declare -x SCR_TEST_STY_TEST_RESULT=$SCR_TMPDIR/esh-test-sty-test-result
  declare -x SCR_TEST_STY_STDOUT=$SCR_TMPDIR/esh-test-sty-stdout
  declare -x SCR_TEST_STY_STDERR=$SCR_TMPDIR/esh-test-sty-stderr

  for f in $SCR_TEST_STY_TEST_RESULT $SCR_TEST_STY_STDOUT $SCR_TEST_STY_STDERR; do
    if [ ! -e $f ]; then
      mkfifo $f
    fi
  done

  set -e
  trap -- '-cleanup;exit' INT QUIT HUP EXIT

  -cleanup() {
    echo "inside $FUNCNAME"
    if [ -z "$STY" ]; then
      for f in $SCR_TEST_STY_TEST_RESULT $SCR_TEST_STY_STDOUT $SCR_TEST_STY_STDERR; do
        echo "rm $f"
        rm -f $f
      done
    fi
    if [ "$SCR_TEST_STY" ] && screen -ls | grep -q $SCR_TEST_STY; then
      echo "force quit STY=$SCR_TEST_STY"
      env screen -S $SCR_TEST_STY -X quit
    fi
  }

  if [ "$STY" ]; then
    echo "$FUNCNAME: please do not run this inside gnu screen" >&2
    return 1
  fi

  printf "************************************************\n"
  printf "START TEST SPECS on $(tty)\n"
  printf "************************************************\n"
  for assertion in "${SCR_TEST_ASSERTIONS[@]}"; do
    -assert -- "$assertion"
  done

  if [ $assertion_fails -gt 0 ]; then
    status=FAIL
    printf "final status: FAIL (%s/%s failed assertions), see %s for current environment\n" $assertion_fails $assertion_counter $env_file
    set > $env_file
  else
    printf "************************************************\n"
    printf "final status: PASS (%s/%s successful assertions)\n" $assertion_successes $assertion_counter
    printf "************************************************\n"
  fi
  return $assertion_fails
)
