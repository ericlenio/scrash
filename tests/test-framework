# vim filetype=bash

-assert() {
  local status=FAIL assertion opts="br:" opt OPTIND base64=0 raw_mode_named_pipe
  while builtin getopts "$opts" opt; do
    case $opt in
      (b)
        # assertion is base 64 encoded
        base64=1
        ;;
      (r)
        raw_mode_named_pipe=$OPTARG
        ;;
    esac
  done
  [ $OPTIND -gt 1 ] && shift $(($OPTIND-1))
  assertion="$1"
  if [ $base64 = 1 ]; then
    assertion="$(echo $assertion | openssl enc -d -a -A)"
  fi
  if eval -- "$assertion"; then
    status="PASS"
  fi
  if [ -z "$raw_mode_named_pipe" ]; then
    -assert-result $status "$assertion"
    #printf "%s. %s: %s\n" $num_assertions $status "$assertion"
  else
    printf "%s\t%s\n" $status "$assertion" >$raw_mode_named_pipe
  fi
  if [ $status = FAIL ]; then
    return 1
  fi
}

-assert-result() {
  local status=$1 assertion="$2"
  let assertion_counter+=1
  printf "%s %s. %s: %s\n" $SCR_TEST_GROUP $assertion_counter $status "$assertion"
  if [ $status = PASS ]; then
    let assertion_successes+=1
  else
    let assertion_fails+=1
    return 1
  fi
}

-test-sty-launch() {
  local STY_ID="$1" i n eof_stdout=0 eof_stderr=0 result
  set -e

  screen -S $STY_ID -X screen bash -c -- '"$@"' -- -test-sty "${SCR_TEST_STY_ASSERTIONS[@]}"
  while :; do
    unset REPLY
    if ! read -d '' <$SCR_TEST_STY_STDOUT; then
      eof_stdout=1
    fi
    if [ "$REPLY" ]; then
      echo "$REPLY"
    fi
    if [ $eof_stdout = 1 ]; then
      break
    fi
  done &

  # noting that stderr is properly closed, but stdout still listening for
  # output; "echo -n '' > stdout" seems to close it
  while :; do
    unset REPLY
    if ! read -d '' <$SCR_TEST_STY_STDERR; then
      eof_stderr=1
    fi
    if [ "$REPLY" ]; then
      echo "$REPLY" >&2
    fi
    if [ $eof_stderr = 1 ]; then
      break
    fi
  done &

  n=${#SCR_TEST_STY_ASSERTIONS[@]}
  for ((i=0;i<$n;i++)); do
    IFS=$'\t' read -t 1 -ra result <$SCR_TEST_STY_TEST_RESULT || true
    -assert-result "${result[@]}"
  done

  wait
}

# this runs the test cases for gnu screen
-test-sty() {
  local assertion
  set -e
  exec 1>$SCR_TEST_STY_STDOUT 2>$SCR_TEST_STY_STDERR
  for assertion in "$@"; do
    -assert -r $SCR_TEST_STY_TEST_RESULT -- "$assertion"
#echo "assertion=$assertion" >$SCR_TEST_STY_TEST_RESULT
  done
  #osascript -e 'tell application (path to frontmost application as text) to display dialog "Hello from osxdaily.com" buttons {"OK"} with icon stop'
}

-ssh-not-strict() {
   # disable "Warning: Permanently added ..." by using error log level
   ssh -oStrictHostKeyChecking=no -oUserKnownHostsFile=/dev/null -oLogLevel=error "$@"
}

-ssh-localhost() {
   -ssh-not-strict localhost "$@"
}

# SCR_TEST_GROUP is just a label for a group of tests
-test-group() {
  local new_group=$1
  if [ "$new_group" != ${SCR_TEST_GROUP:-.} ]; then
    SCR_TEST_GROUP_ASSERTIONS=()
  fi
  SCR_TEST_GROUP=$new_group
}

# check that we only run assertions for the current test groups
-test-group-check() {
  local test_group
  if [ ${#SCR_TEST_GROUPS[*]} -eq 0 -o ${#SCR_TEST_GROUP} -eq 0 ]; then
    return
  fi
  for test_group in ${SCR_TEST_GROUPS[*]}; do
    if [ $test_group = $SCR_TEST_GROUP ]; then
      return
    fi
    if [[ $SCR_TEST_GROUP =~ ^$test_group ]]; then
      return
    fi
  done
  return 1
}

-show-test-groups() {
  local assertion
  for assertion in "${SCR_TEST_ASSERTIONS[@]}"; do
    if [[ "$assertion" =~ ^-test-group ]]; then
      eval -- "$assertion"
      echo $SCR_TEST_GROUP
    fi
  done
}

-run-assertions() {
  local assertion funcdef opts="n" opt OPTIND n_flag=0
  while builtin getopts "$opts" opt; do
    case $opt in
      (n)
        # pause the collection of assertions into SCR_TEST_GROUP_ASSERTIONS
        n_flag=1
        ;;
    esac
  done
  shift $(($OPTIND-1))
  for assertion in "$@"; do
    if [[ "$assertion" =~ ^-test-group ]]; then
      eval -- "$assertion"
      continue
    fi
    if ! -test-group-check; then
      continue
    fi
    if [ $n_flag = 0 ]; then
      if ! [[ "$assertion" =~ ^$SCR_TEST_GROUP ]]; then
        SCR_TEST_GROUP_ASSERTIONS+=("$assertion")
      fi
      local assertions=("${SCR_TEST_GROUP_ASSERTIONS[@]}")
      printf -v funcdef '%s() { %s; -run-assertions -n -- "${assertions[@]}"; }' $SCR_TEST_GROUP "$(declare -p assertions)"
      eval "$funcdef"
    fi
    -assert -- "$assertion"
  done
}

-test() (
  local num_assertions=-1 env_file=$SCR_TMPDIR/esh-test-log opts="g:G" opt OPTIND
  assertion_counter=0
  assertion_successes=0
  assertion_fails=0
  SCR_TEST_GROUPS=()
  while builtin getopts "$opts" opt; do
    case $opt in
      (g)
        SCR_TEST_GROUPS=($(echo "$OPTARG" | tr "[:lower:]" "[:upper:]"))
        ;;
      (G)
        -show-test-groups
        return
        ;;
    esac
  done

  -clear-cache

  declare -x SCR_TEST_STY_TEST_RESULT=$SCR_TMPDIR/esh-test-sty-test-result
  declare -x SCR_TEST_STY_STDOUT=$SCR_TMPDIR/esh-test-sty-stdout
  declare -x SCR_TEST_STY_STDERR=$SCR_TMPDIR/esh-test-sty-stderr

  for f in $SCR_TEST_STY_TEST_RESULT $SCR_TEST_STY_STDOUT $SCR_TEST_STY_STDERR; do
    if [ ! -e $f ]; then
      mkfifo $f
    fi
  done

  set -e
  trap -- 'trap - INT QUIT HUP EXIT;-cleanup;exit' INT QUIT HUP EXIT

  -cleanup() {
    echo "inside $FUNCNAME"
    if [ -z "$STY" ]; then
      for f in $SCR_TEST_STY_TEST_RESULT $SCR_TEST_STY_STDOUT $SCR_TEST_STY_STDERR; do
        echo "rm $f"
        rm -f $f
      done
    fi
    if [ "$SCR_TEST_STY" ] && screen -ls | grep -q $SCR_TEST_STY; then
      echo "force quit STY=$SCR_TEST_STY"
      env screen -S $SCR_TEST_STY -X quit
    fi
  }

  if [ "$STY" ]; then
    echo "$FUNCNAME: please do not run this inside gnu screen" >&2
    return 1
  fi

  printf "************************************************\n"
  printf "START TEST SPECS on $(tty)\n"
  printf "************************************************\n"
  -run-assertions -- "${SCR_TEST_ASSERTIONS[@]}"
  printf "************************************************\n"
  if [ $assertion_fails -gt 0 ]; then
    status=FAIL
    printf "final status: FAIL (%s/%s failed assertions), see %s for current environment\n" $assertion_fails $assertion_counter $env_file
    set > $env_file
  else
    printf "final status: PASS (%s/%s successful assertions)\n" $assertion_successes $assertion_counter
  fi
  printf "************************************************\n"
  return $assertion_fails
)
